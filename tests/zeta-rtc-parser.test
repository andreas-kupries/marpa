# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::engine::tcl::rtc-critcl + z-marpa-tcl
##

##
## Larger testing of exporter results, and runtime -- export::rtc-critcl, rtc
## 

kt require support critcl   ;# compile & run

# # ## ### ##### ######## ############# #####################
## API to the parser-core

proc label  {} { return "engine_rtc_slif" }
proc pclass {} { return engine-rtc-parser }

proc result {base} {
    foreach file {
	ast_rtc
	ast
    } {
	set path [file join $base $file]
	if {![file exists $path]} continue
	return $path
    }
    return -code error "Unable to find result for $base"
}

proc initialize {} {
    # _ __ ___ _____ ________ _____________ _____________________
    # The builtin lexer, parser and uncore are used to process the
    # SLIF meta grammar and create a full-blown tcl-based engine for
    # it (via the proper exporter). This engine is used, in turn, to
    # process all the test cases.

    # _ __ ___ _____ ________ _____________ _____________________
    # I. Create the processor
    marpa::slif::container create GC
    marpa::slif::semantics create SEMA GC
    marpa::slif::parser    create BOOT

    # _ __ ___ _____ ________ _____________ _____________________
    # II. Process the slif meta grammar
    SEMA process [BOOT process-file [MetaLocation]/slif]
    # GC now holds the grammar
    BOOT destroy
    # Note: SEMA auto-destroys itself at the end of 'process'.

    # _ __ ___ _____ ________ _____________ _____________________
    # III. Generate an rtc-based critcl parser class for it
    marpa::export config! version  1
    marpa::export config! writer   {Jeffrey Kegler + Andreas Kupries}
    marpa::export config! year     2017
    marpa::export config! name     [pclass]
    marpa::export config! operator $::tcl_platform(user)@[info hostname]
    marpa::export config! tool     [info script]

    set parser [marpa::export::rtc-critcl container GC]
    GC destroy
    # Write to file for debugging and loading
    fileutil::writeFile [ParserFile] $parser

    # _ __ ___ _____ ________ _____________ _____________________
    # IV. Load and activate the new class.
    #     Critcl compile & run
    #     We go through an external file to ensure proper keying
    #     by [info script] in critcl.

    # Access to the RTC sources
    exec ln -s [file normalize [td]/../rtc] rtc
    exec ln -s [file normalize [td]/../c] c
    # read
    source [ParserFile]
    file delete rtc c
    # Actual compile to and loading of shlib happens on first use.
    # _ __ ___ _____ ________ _____________ _____________________
    #catch { memory validate on }
    return
}

proc finalize {} {
    #catch { memory validate off }
    removeFile [ParserFile];#Disable when debugging
    rename ParserFile {}
    rename MetaLocation {}
    return
}

proc MetaLocation {} {
    return [td]/grammars/z-marpa-tcl
}

proc ParserFile {} {
    return [td]/[pclass].tcl
}

# # ## ### ##### ######## ############# #####################
##

kt source parser-core.testsuite

# # ## ### ##### ######## ############# #####################
cleanupTests
