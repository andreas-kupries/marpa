# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::tcl::lex - Aggregated lexer pipeline.

## Uses the boot-parser and export_tlex to generate a lexer based on
## the rt_lex runtime, and then uses that to test the runtime's
## behaviour with respect to the supported semantic actions.

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO
kt require support fileutil ;# writeFile

kt local   testing marpa

# # ## ### ##### ######## ############# #####################

kt source support/dirs.tcl
#kt source support/grammars.tcl
#kt source support/textutils.tcl
#kt source support/common.tcl
#kt source support/lexample.tcl
#kt source support/fake-parse.tcl
#kt source support/fake-store.tcl

# # ## ### ##### ######## ############# #####################
## Setup dynamic parts of the testsuite
## Currently only importing the `bootstrap/marpa-tcl-slif`

exec [td]/grammars/setup.sh

# # ## ### ##### ######## ############# #####################
##

proc meta {} {
    return [td]/grammars/z-marpa-tcl
}

proc rt-lex-code {} {
    return [td]/zeta-lexer.tcl
}

proc finalize {} {
    #removeFile [rt-lex-code]
    rename initialize {}
    rename rt-lex-code {}
    rename meta {}
    rename finalize {}
    return
}

proc initialize {} {
    # _ __ ___ _____ ________ _____________ _____________________
    # Process the slif meta grammar
    marpa::slif::container create GC
    marpa::slif::semantics create SEMA GC
    marpa::slif::parser    create BOOT
    SEMA process [BOOT process-file [meta]/slif]
    # GC now holds the grammar
    BOOT destroy
    # Note: SEMA auto-destroys at the end of 'process'.
    # _ __ ___ _____ ________ _____________ _____________________
    # Generate a lexer class for it
    marpa::export config! version  1
    marpa::export config! writer   {Jeffrey Kegler + Andreas Kupries}
    marpa::export config! year     2017
    marpa::export config! name     meta-lexer
    marpa::export config! operator $::tcl_platform(user)@[info hostname]
    marpa::export config! tool     [info script]
    set parser [marpa::export::tlex container GC]
    GC destroy
    # _ __ ___ _____ ________ _____________ _____________________
    # Write to file for debugging.
    fileutil::writeFile [rt-lex-code] $parser
    # Activate for use.
    uplevel #0 $parser
    # _ __ ___ _____ ________ _____________ _____________________
    return
}

proc capture {m args} {
    if {$m ne "enter"} return
    # args = list (list(symbol), list(value))
    lassign $args symbols svalues
    set svalues [lsort -uniq $svalues]
    if {[llength $svalues] == 1} {
	set svalues [lindex $svalues 0]
    }
    lappend ::TRACE $svalues
    return
}

# # ## ### ##### ######## ############# #####################

initialize

# # ## ### ##### ######## ############# #####################
##

foreach {lexaction joiner} {
    g1length { }
    g1start  { }
    length   \n
    lhs      \n
    name     \n
    rule     \n
    start    \n
    symbol   \n
    value    \n
    values   \n
} {
    incr k
    #exec touch [meta]/rtlex-action-$lexaction
    
    test marpa-lexer-1.0.${k}-${lexaction} "marpa::tcl::lex, action (($lexaction))" -setup {
	# Generate a derived class overriding the lexer semantics to what
	# we are testing.
	oo::class create LRT.$k
	oo::define LRT.$k superclass meta-lexer
	oo::define LRT.$k method Semantics {} [list return $lexaction]
	if 0 {oo::define LRT.$k method Semantics {} [string map [list @@ $lexaction] {
	    puts "XXX @@"
	    return @@
	}]}
	LRT.$k create LEX
	set TRACE {}
    } -body {
	LEX process-file [meta]/slif capture
	join $TRACE $joiner
    } -cleanup {
	LEX destroy
	LRT.$k destroy
	# This leaves some sort of Delegate behind.
	unset TRACE
    } -result [viewFile [meta]/rtlex-action-$lexaction]
}

# # ## ### ##### ######## ############# #####################
finalize
cleanupTests
