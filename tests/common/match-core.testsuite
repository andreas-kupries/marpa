# -*- tcl -*-
## (c) 2018 Andreas Kupries
# # ## ### ##### ######## ############# #####################

## Execution core for testing the marpa runtime engines with various
## SLIF-specified grammars demonstrating various features and possible
## behaviours. This is similiar to parser-core, one stage further.

## Specialized form of the `runtime-core.testsuite` to test the
## `match` ensemble with regard to argument validation, and access
## control.

## Configured by the caller with methods for
## - overall initialization and finalization
## - parser creation and destruction
## - Result selection
#
## The methods expected to exist are
#
## * label      :: return string to name the tests
## * initialize :: global setup, for the suite
## * finalize   :: global cleanup, for the suite
## * input      :: input selection by label / base directory
## * result     :: result selection by label / base directory

## The name of the parser class is stored in the `gen` config, under
## key `cl`.

# # ## ### ##### ######## ############# #####################

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO
kt require support fileutil ;# cat

# # ## ### ##### ######## ############# #####################
## Local shorthands

proc setup   {} { [gen cget cl] create PARSE }
proc cleanup {} { PARSE destroy }

proc stash {k} {
    global rtdebug
    #if {![info exists rtdebug] || !$rtdebug} return
    set dst [top]/[label]_${k}-stash
    file delete -force $dst
    file mkdir $dst
    set cl [gen cget cl]

    file copy [td]/${cl}.tcl     $dst/
    # RTC specific. Not for Tcl.
    catch {
	file copy [td]/OUT_${cl}_LOG $dst/
	file copy [td]/OUT_${cl}     $dst/
    }
    return
}

# # ## ### ##### ######## ############# #####################
## No method sequence checking for the parser.
## Methods can be called in any order.

# # ## ### ##### ######## ############# #####################

kt source support/ast.tcl
kt source support/dirs.tcl
kt source support/grammars.tcl
kt source support/textutils.tcl

# # ## ### ##### ######## ############# #####################
## Setup dynamic parts of the testsuite
## Currently only importing the `bootstrap/marpa-tcl-slif`

exec [td]/grammars/setup.sh

# # ## ### ##### ######## ############# #####################

initialize

# # ## ### ##### ######## ############# #####################
## Actual processing - Id formatting prep

incr max
test-grammar-files rt_example --> __ __ { incr max }
set format %0[string length $max]d
unset max

# # ## ### ##### ######## ############# #####################

set commands {
    0 {location? X}
    1 location?
    0 moveto
    0 {moveto {}}
    0 {moveto -1}
    1 {moveto 0}
    0 location?
    0 moveby
    0 {moveby {}}
    1 {moveby 5}
    0 location?
    0 {moveby -5}
    0 location?
    0 rewind
    0 {rewind {}}
    0 {rewind -5}
    0 location?
    1 {rewind 5}
    0 location?
    0 {stop? X}
    1 stop?
    0 stop-at
    0 {stop-at {}}
    0 {stop-at -1}
    1 {stop-at 10}
    0 stop?
    0 limit
    0 {limit {}}
    0 {limit -1}
    1 {limit 10}
    0 stop?
    0 {symbols X}
    1 symbols
    0 {sv X}
    1 sv
    0 {start X}
    1 start
    0 {length X}
    1 length
    0 {value X}
    1 value
    0 {values X}
    1 values
    0 symbols:
    1 {symbols: {}}
    0 sv:
    1 {sv: {}}
    0 start:
    0 {start: {}}
    0 {start: -1}
    1 {start: 0}
    0 length:
    0 {length: {}}
    0 {length: -1}
    1 {length: 10}
    0 value:
    1 {value: {}}
    0 values:
    1 {values: {}}
    0 alternate
    0 {alternate {}}
    0 {alternate {} {} X}
    1 {alternate A V}
    0 {view X}
    1 view
}

proc record {p type enames args} {
    global commands
    lappend ::recording ___________________________(([info level 0]))

    # Go through all methods of the match api and record their
    # responses. Validation, event-specific access control, etc.
    foreach {___ cmd} $commands {
	set state [catch {
	    $p match {*}$cmd
	} result]
	lappend ::recording "___ (( $cmd ))" "_ => $state" "_ ~~ `$result`" ""
    }

    # Force clear symbol/sv where possible
    catch { $p match symbols: {} }
    catch { $p match sv:      {} }

    # And move to the end of the input.
    # This forces the engine to abort.
    $p match moveto [string length $input]
    return
}

# # ## ### ##### ######## ############# #####################

set outside 1
incr k
test-grammar-map rt_example --> id rte base {    
    if {![file exists $base/match]} continue
    # Use only match examples.

    gen configure gr $rte
    gen setup cl rte${k}_[label]

    # Debugging - Keep the generated parser and related files for
    # post-mortem review.
    stash $k

    set input  [fget [input  $base]]
    set kd     [format $format $k]

    # Get the expected match API behaviour
    set result [string trimright [fget $base/match]]

    if {$outside} {
	set outside 0

	foreach {ok cmd} $commands {
	    incr j
	    if {!$ok} continue
	    set jd [format "%02d" $j]
	    test marpa-[label]-events-match-1.${jd}-$id "[label] :: events match outside $cmd" -body {
		PARSE match {*}$cmd
	    } -setup {
		setup
	    } -cleanup {
		cleanup
	    } -returnCodes error \
		-result {Invalid access to match state, not inside event handler}
	}

	## TODO: create a test with stop event. See below for lexing/parsing events.
    }
    
    test marpa-[label]-events-match-3.${kd}---${id} "[label] :: events match $id" -body {
	catch {
	    PARSE process $input
	    join $recording \n
	} msg
	set msg ;# set ::errorInfo
    } -setup {
	set recording {}
	setup
	PARSE on-event record
    } -cleanup {
	cleanup
	unset msg recording
    } -result $result

    gen cleanup
    incr k
}

# # ## ### ##### ######## ############# #####################
unset k base format result kd input rte
rename record  {}
rename setup   {}
rename cleanup {}

# # ## ### ##### ######## ############# #####################
finalize

# # ## ### ##### ######## ############# #####################
rename label      {}
rename result     {}
rename initialize {}
rename finalize   {}
return
