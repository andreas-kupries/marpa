# -*- tcl -*-
## (c) 2017-2018 Andreas Kupries
# # ## ### ##### ######## ############# #####################

## Execution core for testing the marpa runtime engines with various
## SLIF-specified grammars demonstrating various features and possible
## behaviours. This is similiar to parser-core, one stage further.

## Configured by the caller with methods for
## - overall initialization and finalization
## - parser creation and destruction
## - Result selection
#
## The methods expected to exist are
#
## * label      :: return string to name the tests
## * initialize :: global setup, for the suite
## * finalize   :: global cleanup, for the suite
## * input      :: input selection by label / base directory
## * result     :: result selection by label / base directory

## The name of the parser class is stored in the `gen` config, under
## key `cl`.

# # ## ### ##### ######## ############# #####################

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO
kt require support fileutil ;# cat

# # ## ### ##### ######## ############# #####################
## Local shorthands

proc setup   {} { [gen cget cl] create PARSE }
proc cleanup {} { PARSE destroy }

proc stash {k} {
    global rtdebug
    if {![info exists rtdebug] || !$rtdebug} return
    set dst [top]/[label]_${k}-stash
    file delete -force $dst
    file mkdir $dst
    set cl [gen cget cl]

    file copy [td]/${cl}.tcl     $dst/
    # RTC specific. Not for Tcl.
    catch {
	file copy [td]/OUT_${cl}_LOG $dst/
	file copy [td]/OUT_${cl}     $dst/
    }
    return
}

# # ## ### ##### ######## ############# #####################
## No method sequence checking for the parser.
## Methods can be called in any order.

# # ## ### ##### ######## ############# #####################

kt source support/ast.tcl
kt source support/dirs.tcl
kt source support/grammars.tcl
kt source support/textutils.tcl

# # ## ### ##### ######## ############# #####################
## Setup dynamic parts of the testsuite
## Currently only importing the `bootstrap/marpa-tcl-slif`

exec [td]/grammars/setup.sh

# # ## ### ##### ######## ############# #####################

initialize

# # ## ### ##### ######## ############# #####################
## Actual processing - Id formatting prep

incr max
test-grammar-files rt_example --> __ __ { incr max }
set format %0[string length $max]d
unset max

# # ## ### ##### ######## ############# #####################

incr k
test-grammar-map rt_example --> id rte base {
    gen configure gr $rte
    gen setup cl rte$k

    # Debugging - Keep the generated parser and related files for
    # post-mortem review.
    stash $k

    set input  [fget [input  $base]]
    set kd     [format $format $k]

    if {[file exists $base/events]} {
	# runtime example for events
	set result [string trimright [fget $base/events]]

	test marpa-[label]-runtime-process-2.${kd}---${id} "[label] :: process $id" -body {
	    catch {
		PARSE process $input
		join $recording \n
	    } msg
	    set msg ;# set ::errorInfo
	} -setup {
	    set recording {}
	    proc record {p type enames args} {
		# For testing we just record the information about the
		# event for matching against expectations.
		if {[catch {
		    lappend ::recording ___________________________(([info level 0]))
		    lappend ::recording {*}[$p match view]
		    # Move input so that lexer resumes reading with
		    # the character after the lexeme.  Written as is
		    # with absolutes so that it works for all events
		    # (discard, pre-, post-lexeme) we are testing
		    # without requiring conditionals
		    $p match moveto [$p match start] [$p match length] -1
		    lappend ::recording "@resume = [$p match location?]"
		    # The input now points to the last character of
		    # the lexeme, and on resume the lexer advances to
		    # the next character to start processing from.
		}]} {
		    lappend ::recording $::errorInfo
		}
		return
	    }
	    setup
	    PARSE on-event record
	} -cleanup {
	    cleanup
	    rename record {}
	    unset msg recording
	} -result $result

    } else {
	# runtime example for AST
	set result [string trimright [fget [result $base]]]

	test marpa-[label]-runtime-process-2.${kd}---${id} "[label] :: process $id" -body {
	    catch {
		ast-format [PARSE process $input]
	    } msg
	    set msg ;# set ::errorInfo
	} -setup setup -cleanup {
	    cleanup
	    unset msg
	} -result $result
    }

    gen cleanup
    incr k
}

# # ## ### ##### ######## ############# #####################
unset k base format result kd input rte
rename setup   {}
rename cleanup {}

# # ## ### ##### ######## ############# #####################
finalize

# # ## ### ##### ######## ############# #####################
rename label      {}
rename result     {}
rename initialize {}
rename finalize   {}
return
