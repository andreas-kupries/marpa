# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::export::tlex::template

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller

kt local   testing marpa

# # ## ### ##### ######## ############# #####################
##  [ok] get

# # ## ### ##### ######## ############# #####################
## get

test marpa-export-tlex-template-get-1.0 {get, wrong args, too many} -body {
    marpa::export::tlex::template get X
} -returnCodes error -result {wrong # args: should be "marpa::export::tlex::template get"}

test marpa-export-tlex-template-get-2.0 {get} -body {
    marpa::export::tlex::template get
} -result {# -*- tcl -*-
##
# This template is BSD-licensed.
# (c) 2017 Template - Andreas Kupries http://wiki.tcl.tk/andreas%20kupries
#                                     http://core.tcl.tk/akupries/
##
# (c) @slif-year@ Grammar @slif-name@ By @slif-writer@
##
##	TLex (*) Engine for SLIF Grammar "@slif-name@"
##	Generated On @generation-time@
##		  By @tool-operator@
##		 Via @tool@
##
##	(*) Tcl-based Lexer-only

package provide @slif-name@ @slif-version@

# # ## ### ##### ######## #############
## Requisites

package require marpa	      ;# marpa::slif::container
package require Tcl 8.5       ;# -- Foundation
package require TclOO         ;# -- Implies Tcl 8.5 requirement.
package require debug         ;# Tracing
package require debug::caller ;#

# # ## ### ##### ######## #############

debug define marpa/grammar/@slif-name@
debug prefix marpa/grammar/@slif-name@ {[debug caller] | }

# # ## ### ##### ######## #############

oo::class @slif-name@ {
    superclass marpa::engine::tcl::lex

    # Lifecycle: No constructor needed. No state.
    # All data is embedded as literals into methods

    # Declare the various things needed by the engine for its
    # operation.  To get the information the base class will call on
    # these methods in the proper order. The methods simply return the
    # requested information. Their base-class implementations simply
    # throw errors, thus preventing the construction of an incomplete
    # lexer.
    
    method Characters {} {
	debug.marpa/grammar/@slif-name@
	# Literals: The directly referenced (allowed) characters.
	return {@characters@}
    }
    
    method Classes {} {
	debug.marpa/grammar/@slif-name@
	# Literals: The character classes in use
	return {@classes@}
    }
    
    method Lexemes {} {
	debug.marpa/grammar/@slif-name@
	# Lexer API: Lexeme symbols (Cannot be terminal).
	return {@lexemes@}
    }
    
    method Discards {} {
	debug.marpa/grammar/@slif-name@
	# Discarded symbols (whitespace)
	return {@discards@}
    }
    
    method Symbols {} {
	# Non-lexeme, non-literal symbols
	debug.marpa/grammar/@slif-name@
	return {@symbols@}
    }

    method Rules {} {
	# Rules for all symbols but the literals
	debug.marpa/grammar/@slif-name@
	return {@rules@}
    }

    method Semantics {} {
	debug.marpa/grammar/@slif-name@
	# NOTE. This is currently limited to array semantics.
	# NOTE. No support for command semantics in the lexer yet.
	return {@semantics@}
    }
}

# # ## ### ##### ######## #############
return}

# # ## ### ##### ######## ############# #####################
cleanupTests
