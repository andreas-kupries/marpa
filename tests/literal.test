# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::slif::literal

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO

kt local   testing marpa

# # ## ### ##### ######## ############# #####################

kt source support/common.tcl
kt source support/dirs.tcl
kt source support/textutils.tcl

# # ## ### ##### ######## ############# #####################
## [..] symbol        \
## [ok] parse         / API
## [ok] norm          \
## [ok] eltype        | Helpers. Exposed for testing internals
## [ok] ccunfold      | (before testing the visible API)
## [ok] ccsplit       |   |
## [ok] decode        \___/
## [ok] decode-string /
## [ok] decode-class  |
## [ok] type          |
## [ok] unescape      |
## [ok] tags          

# # ## ### ##### ######## ############# #####################
## r2container - Transfer a reduction result into a container

test marpa-slif-literal-r2container-1.0 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container worklist container"}

test marpa-slif-literal-r2container-1.1 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container worklist container"}

test marpa-slif-literal-r2container-1.2 {r2container, wrong args, too many} -body {
    marpa::slif::literal r2container W C X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container worklist container"}

test marpa-slif-literal-r2container-2.0 {r2container, nothing} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {} $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result {}

test marpa-slif-literal-r2container-2.1 {r2container, all cases} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {
	C {composite {A} {B}}
	S {composite {A B}}
	A {character 65}
	B {character 66}
    } $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result [norm-trace [file join [trdir] r2c21]]

# # ## ### ##### ######## ############# #####################
## reduce - reduction to minimum

test marpa-slif-literal-reduce-1.0 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.1 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.2 {reduce, wrong args, too many} -body {
    marpa::slif::literal reduce W R X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

proc F {defs} {
    join [lmap {sym lit} $defs { list $sym $lit }] \n
}

proc FE {str} {
    join [lmap line [split [string trim $str] \n] {
	string trim $line
    }] \n
}

set k 0
foreach {literal toexpect} {
    string {
	{} error {Unable to reduce incomplete literal (string ())}
    }
    {string 65 66 300} {
	{}     error {Unable to reduce type (string (65 66 300))}
	K-STR  ok    {<symbol> {string 65 66 300}}
	D-STR1 error {Unable to reduce type (character (300))}
	{D-STR1 K-CHR} ok {
	    @CHR:<A> {character 65}
	    @CHR:<B> {character 66}
	    {@CHR:<\u012c>} {character 300}
	    <symbol> {composite {@CHR:<A> @CHR:<B> {@CHR:<\u012c>}}}
	}
	{D-STR1 D-CHR} ok {
	    @BYTE:<A> {byte 65}
	    @CHR:<A> {composite @BYTE:<A>}
	    @BYTE:<B> {byte 66}
	    @CHR:<B> {composite @BYTE:<B>}
	    {@BYTE:<\u00c4>} {byte 196}
	    {@BYTE:<\u00ac>} {byte 172}
	    {@CHR:<\u012c>} {composite {{@BYTE:<\u00c4>} {@BYTE:<\u00ac>}}}
	    <symbol> {composite {@CHR:<A> @CHR:<B> {@CHR:<\u012c>}}}
	}
	D-STR2 ok {
	    @BYTE:<A> {byte 65}
	    @BYTE:<B> {byte 66}
	    {@BYTE:<\u00c4>} {byte 196}
	    {@BYTE:<\u00ac>} {byte 172}
	    <symbol> {composite {@BYTE:<A> @BYTE:<B> {@BYTE:<\u00c4>} {@BYTE:<\u00ac>}}}
	}
    }
} {
    # Incrementally fill the above table with cases.  The basic flow
    # is covered by what we have now. Extending this is not about
    # coverage anymore, but about seeing the whole deconstruction for
    # all literal types and possible rule-sets.
    
    incr k
    set j 0
    foreach {rules code result} $toexpect {
	incr j

	test marpa-slif-literal-reduce-2.$k.$j "reduce $code ($literal) $rules" -body {
	    F [marpa::slif::literal reduce [list <symbol> $literal] $rules]
	} -returnCodes $code -result [FE $result]
    }
}

rename F {}
rename FE {}

# # ## ### ##### ######## ############# #####################
## reduce1 - single reduction step

test marpa-slif-literal-reduce1-1.0 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.1 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.2 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.3 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.4 {reduce1, wrong args, too many} -body {
    marpa::slif::literal reduce1 S L R S X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

set     map {}
lappend map @@@ [marpa unicode max]
lappend map @! {STATE place done work <symbol>}
#lappend map @= {STATE place done done <symbol>}
lappend map @q {STATE queue done <symbol>}
lappend map @x {STATE queue work <symbol>}

set k 0
foreach {literal toexpect} {
    string {
	{}     error {Unable to reduce incomplete literal (string ())}
	K-STR  error {Unable to reduce incomplete literal (string ())}
	D-STR1 error {Unable to reduce incomplete literal (string ())}
	D-STR2 error {Unable to reduce incomplete literal (string ())}
    }
    {string 65 66 300} {
	{}     error {Unable to reduce type (string (65 66 300))}
	K-STR  ok    {@q {string 65 66 300}}
	D-STR1 ok    {@! {composite {{character 65} {character 66} {character 300}}}}
	D-STR2 ok    {@! {composite {{byte 65} {byte 66} {byte 196} {byte 172}}}}
    }
    %string {
	{}     error {Unable to reduce incomplete literal (%string ())}
	K-%STR error {Unable to reduce incomplete literal (%string ())}
	D-%STR error {Unable to reduce incomplete literal (%string ())}
    }
    {%string 97 98} {
	{}     error  {Unable to reduce type (%string (97 98))}
	K-%STR ok     {@q {%string 97 98}}
	D-%STR ok     {@! {composite {{%character 97} {%character 98}}}}
	!----- ------ { -- reduce1 ^^ does not normalize, rstate place does -- }
    }
    character {
	{}    error {Unable to reduce incomplete literal (character ())}
	K-CHR error {Unable to reduce incomplete literal (character ())}
	D-CHR error {Unable to reduce incomplete literal (character ())}
    }
    {character 65} {
	{}    error {Unable to reduce type (character (65))}
	K-CHR ok    {@q {character 65}}
	D-CHR ok    {@! {composite {{byte 65}}}}
    }
    {character 300} {
	{}    error {Unable to reduce type (character (300))}
	K-CHR ok    {@q {character 300}}
	D-CHR ok    {@! {composite {{byte 196} {byte 172}}}}
	!---- ----- {                     ^110.00100 ^10.101100   }
	!---- ----- {                     = 0b'00100  0b'101100   }
	!---- ----- {                     = 0b'00100 101100 = 300 }
    }
    charclass {
	{}     error {Unable to reduce incomplete literal (charclass ())}
	K-CLS  error {Unable to reduce incomplete literal (charclass ())}
	D-CLS1 error {Unable to reduce incomplete literal (charclass ())}
	D-CLS2 error {Unable to reduce incomplete literal (charclass ())}
	D-CLS3 error {Unable to reduce incomplete literal (charclass ())}
    }
    {charclass {10 20} 300} {
	{}     error {Unable to reduce type (charclass ({10 20} 300))}
	K-CLS  ok    {@q {charclass {10 20} 300}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{character 300}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 196} {byte 172}}}}
	D-CLS3 ok    {@q {charclass {10 20} 300}}
    }
    {charclass {10 20} braille} {
	{}     error {Unable to reduce type (charclass ({10 20} braille))}
	K-CLS  ok    {@q {charclass {10 20} braille}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass {10 20} {0x2800 0x28FF}}}
    }
    {charclass 300 braille} {
	{}     error {Unable to reduce type (charclass (300 braille))}
	K-CLS  ok    {@q {charclass 300 braille}}
	D-CLS1 ok    {@! {composite {{character 300}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{byte 196} {byte 172}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass 300 {0x2800 0x28FF}}}
    }
    {charclass 300 print} {
	{}     error {Unable to reduce type (charclass (300 print))}
	K-CLS  ok    {@q {charclass 300 print}}
	D-CLS1 ok    {@! {composite {{character 300}} {{named-class print}}}}
	!----- --    { D-CLS2 skipped, avoid large ASBR }
	D-CLS3 ok    {@q {charclass 300 print}}
    }
    {charclass {10 20} 300 braille} {
	{}     error {Unable to reduce type (charclass ({10 20} 300 braille))}
	K-CLS  ok    {@q {charclass {10 20} 300 braille}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{character 300}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 196} {byte 172}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass {10 20} 300 {0x2800 0x28FF}}}
    }
    ^charclass {
	{}     error {Unable to reduce incomplete literal (^charclass ())}
	K-^CLS error {Unable to reduce incomplete literal (^charclass ())}
	D-^CLS error {Unable to reduce incomplete literal (^charclass ())}
    }
    {^charclass {10 20} 300} {
	{}     error {Unable to reduce type (^charclass ({10 20} 300))}
	K-^CLS ok    {@q {^charclass {10 20} 300}}
	D-^CLS ok    {@x {charclass {0 9} {21 299} {301 @@@}}}
    }
    {^charclass {10 20} braille} {
	{}     error {Unable to reduce type (^charclass ({10 20} braille))}
	K-^CLS ok    {@q {^charclass {10 20} braille}}
	D-^CLS ok    {@x {charclass {0 9} {21 10239} {10496 @@@}}}
    }
    {^charclass 300 braille} {
	{}     error {Unable to reduce type (^charclass (300 braille))}
	K-^CLS ok    {@q {^charclass 300 braille}}
	D-^CLS ok    {@x {charclass {0 299} {301 10239} {10496 @@@}}}
    }
    {^charclass {10 20} 300 braille} {
	{}     error {Unable to reduce type (^charclass ({10 20} 300 braille))}
	K-^CLS ok    {@q {^charclass {10 20} 300 braille}}
	D-^CLS ok    {@x {charclass {0 9} {21 299} {301 10239} {10496 @@@}}}
    }
    named-class {
	{}     error {Unable to reduce incomplete literal (named-class ())}
	K-NCC  error {Unable to reduce incomplete literal (named-class ())}
	D-NCC1 error {Unable to reduce incomplete literal (named-class ())}
	D-NCC2 error {Unable to reduce incomplete literal (named-class ())}
    }
    {named-class braille} {
	{}     error {Unable to reduce type (named-class (braille))}
	K-NCC  ok    {@q {named-class braille}}
	D-NCC1 ok    {@x {charclass {0x2800 0x28FF}}}
	D-NCC2 ok    {@! {composite {{byte 226} {brange 160 163} {brange 128 191}}}}
    }
    %named-class {
	{}      error {Unable to reduce incomplete literal (%named-class ())}
	K-%NCC  error {Unable to reduce incomplete literal (%named-class ())}
	D-%NCC1 error {Unable to reduce incomplete literal (%named-class ())}
	D-%NCC2 error {Unable to reduce incomplete literal (%named-class ())}
    }
    {%named-class braille} {
	{}      error {Unable to reduce type (%named-class (braille))}
	K-%NCC  ok    {@q {%named-class braille}}
	D-%NCC1 ok    {@x {charclass {10240 10495}}}
	D-%NCC2 ok    {@! {composite {{byte 226} {brange 160 163} {brange 128 191}}}}
    }
    {%named-class lu} {
	{}      error {Unable to reduce type (%named-class (lu))}
	K-%NCC  ok    {@q {%named-class lu}}
	D-%NCC1 ok    {@x {charclass {65 90} {97 122} 181 {192 214} {216 246} {248 311} {313 328} {330 396} {398 410} {412 425} {428 441} {444 445} 447 {452 495} {497 544} {546 563} {570 596} {598 599} 601 {603 604} {608 609} 611 {613 614} {616 620} 623 {625 626} 629 637 640 643 {647 652} 658 {669 670} 837 {880 883} {886 887} {891 893} 895 902 {904 906} 908 {910 911} {913 929} {931 943} {945 1013} {1015 1019} {1021 1153} {1162 1327} {1329 1366} {1377 1414} {4256 4293} 4295 4301 {5024 5109} {5112 5117} {7296 7304} 7545 7549 {7680 7829} 7835 7838 {7840 7957} {7960 7965} {7968 8005} {8008 8013} 8017 8019 8021 8023 8025 8027 8029 {8031 8061} {8112 8113} {8120 8123} 8126 {8136 8139} {8144 8145} {8152 8155} {8160 8161} 8165 {8168 8172} {8184 8187} 8450 8455 {8459 8461} {8464 8466} 8469 {8473 8477} 8484 8486 8488 {8490 8493} {8496 8499} {8510 8511} 8517 8526 {8579 8580} {11264 11310} {11312 11358} {11360 11376} {11378 11379} {11381 11382} {11390 11491} {11499 11502} {11506 11507} {11520 11557} 11559 11565 {42560 42605} {42624 42651} {42786 42799} {42802 42863} {42873 42887} {42891 42893} {42896 42899} {42902 42926} {42928 42935} 43859 {43888 43967} {65313 65338} {65345 65370}}}
	D-%NCC2 ok    {@! {composite {{brange 65 90}} {{brange 97 122}} {{byte 194} {byte 181}} {{byte 195} {brange 128 150}} {{byte 195} {brange 152 182}} {{byte 195} {brange 184 191}} {{byte 196} {brange 128 183}} {{byte 196} {brange 185 191}} {{byte 197} {brange 128 136}} {{byte 197} {brange 138 191}} {{byte 198} {brange 128 140}} {{byte 198} {brange 142 154}} {{byte 198} {brange 156 169}} {{byte 198} {brange 172 185}} {{byte 198} {brange 188 189}} {{byte 198} {byte 191}} {{byte 199} {brange 132 175}} {{byte 199} {brange 177 191}} {{byte 200} {brange 128 160}} {{byte 200} {brange 162 179}} {{byte 200} {brange 186 191}} {{byte 201} {brange 128 148}} {{byte 201} {brange 150 151}} {{byte 201} {byte 153}} {{byte 201} {brange 155 156}} {{byte 201} {brange 160 161}} {{byte 201} {byte 163}} {{byte 201} {brange 165 166}} {{byte 201} {brange 168 172}} {{byte 201} {byte 175}} {{byte 201} {brange 177 178}} {{byte 201} {byte 181}} {{byte 201} {byte 189}} {{byte 202} {byte 128}} {{byte 202} {byte 131}} {{byte 202} {brange 135 140}} {{byte 202} {byte 146}} {{byte 202} {brange 157 158}} {{byte 205} {byte 133}} {{byte 205} {brange 176 179}} {{byte 205} {brange 182 183}} {{byte 205} {brange 187 189}} {{byte 205} {byte 191}} {{byte 206} {byte 134}} {{byte 206} {brange 136 138}} {{byte 206} {byte 140}} {{byte 206} {brange 142 143}} {{byte 206} {brange 145 161}} {{byte 206} {brange 163 175}} {{byte 206} {brange 177 191}} {{byte 207} {brange 128 181}} {{byte 207} {brange 183 187}} {{byte 207} {brange 189 191}} {{brange 208 209} {brange 128 191}} {{byte 210} {brange 128 129}} {{byte 210} {brange 138 191}} {{byte 211} {brange 128 191}} {{byte 212} {brange 128 175}} {{byte 212} {brange 177 191}} {{byte 213} {brange 128 150}} {{byte 213} {brange 161 191}} {{byte 214} {brange 128 134}} {{byte 225} {byte 130} {brange 160 191}} {{byte 225} {byte 131} {brange 128 133}} {{byte 225} {byte 131} {byte 135}} {{byte 225} {byte 131} {byte 141}} {{byte 225} {byte 142} {brange 160 191}} {{byte 225} {byte 143} {brange 128 181}} {{byte 225} {byte 143} {brange 184 189}} {{byte 225} {byte 178} {brange 128 136}} {{byte 225} {byte 181} {byte 185}} {{byte 225} {byte 181} {byte 189}} {{byte 225} {brange 184 185} {brange 128 191}} {{byte 225} {byte 186} {brange 128 149}} {{byte 225} {byte 186} {byte 155}} {{byte 225} {byte 186} {byte 158}} {{byte 225} {byte 186} {brange 160 191}} {{byte 225} {byte 187} {brange 128 191}} {{byte 225} {byte 188} {brange 128 149}} {{byte 225} {byte 188} {brange 152 157}} {{byte 225} {byte 188} {brange 160 191}} {{byte 225} {byte 189} {brange 128 133}} {{byte 225} {byte 189} {brange 136 141}} {{byte 225} {byte 189} {byte 145}} {{byte 225} {byte 189} {byte 147}} {{byte 225} {byte 189} {byte 149}} {{byte 225} {byte 189} {byte 151}} {{byte 225} {byte 189} {byte 153}} {{byte 225} {byte 189} {byte 155}} {{byte 225} {byte 189} {byte 157}} {{byte 225} {byte 189} {brange 159 189}} {{byte 225} {byte 190} {brange 176 177}} {{byte 225} {byte 190} {brange 184 187}} {{byte 225} {byte 190} {byte 190}} {{byte 225} {byte 191} {brange 136 139}} {{byte 225} {byte 191} {brange 144 145}} {{byte 225} {byte 191} {brange 152 155}} {{byte 225} {byte 191} {brange 160 161}} {{byte 225} {byte 191} {byte 165}} {{byte 225} {byte 191} {brange 168 172}} {{byte 225} {byte 191} {brange 184 187}} {{byte 226} {byte 132} {byte 130}} {{byte 226} {byte 132} {byte 135}} {{byte 226} {byte 132} {brange 139 141}} {{byte 226} {byte 132} {brange 144 146}} {{byte 226} {byte 132} {byte 149}} {{byte 226} {byte 132} {brange 153 157}} {{byte 226} {byte 132} {byte 164}} {{byte 226} {byte 132} {byte 166}} {{byte 226} {byte 132} {byte 168}} {{byte 226} {byte 132} {brange 170 173}} {{byte 226} {byte 132} {brange 176 179}} {{byte 226} {byte 132} {brange 190 191}} {{byte 226} {byte 133} {byte 133}} {{byte 226} {byte 133} {byte 142}} {{byte 226} {byte 134} {brange 131 132}} {{byte 226} {byte 176} {brange 128 174}} {{byte 226} {byte 176} {brange 176 191}} {{byte 226} {byte 177} {brange 128 158}} {{byte 226} {byte 177} {brange 160 176}} {{byte 226} {byte 177} {brange 178 179}} {{byte 226} {byte 177} {brange 181 182}} {{byte 226} {byte 177} {brange 190 191}} {{byte 226} {byte 178} {brange 128 191}} {{byte 226} {byte 179} {brange 128 163}} {{byte 226} {byte 179} {brange 171 174}} {{byte 226} {byte 179} {brange 178 179}} {{byte 226} {byte 180} {brange 128 165}} {{byte 226} {byte 180} {byte 167}} {{byte 226} {byte 180} {byte 173}} {{byte 234} {byte 153} {brange 128 173}} {{byte 234} {byte 154} {brange 128 155}} {{byte 234} {byte 156} {brange 162 175}} {{byte 234} {byte 156} {brange 178 191}} {{byte 234} {byte 157} {brange 128 175}} {{byte 234} {byte 157} {brange 185 191}} {{byte 234} {byte 158} {brange 128 135}} {{byte 234} {byte 158} {brange 139 141}} {{byte 234} {byte 158} {brange 144 147}} {{byte 234} {byte 158} {brange 150 174}} {{byte 234} {byte 158} {brange 176 183}} {{byte 234} {byte 173} {byte 147}} {{byte 234} {byte 173} {brange 176 191}} {{byte 234} {byte 174} {brange 128 191}} {{byte 239} {byte 188} {brange 161 186}} {{byte 239} {byte 189} {brange 129 154}}}}
    }
    ^named-class {
	{}     error {Unable to reduce incomplete literal (^named-class ())}
	K-^NCC error {Unable to reduce incomplete literal (^named-class ())}
	D-^NCC error {Unable to reduce incomplete literal (^named-class ())}
    }
    {^named-class braille} {
	{}     error {Unable to reduce type (^named-class (braille))}
	K-^NCC ok    {@q {^named-class braille}}
	D-^NCC ok    {@x {charclass {0 10239} {10496 @@@}}}
    }
    ^%named-class {
	{}       error {Unable to reduce incomplete literal (^%named-class ())}
	K-^%NCC  error {Unable to reduce incomplete literal (^%named-class ())}
	D-^%NCC1 error {Unable to reduce incomplete literal (^%named-class ())}
	D-^%NCC2 error {Unable to reduce incomplete literal (^%named-class ())}
    }
    {^%named-class braille} {
	{}       error {Unable to reduce type (^%named-class (braille))}
	K-^%NCC  ok    {@q {^%named-class braille}}
	D-^%NCC1 ok    {@x {charclass {0 10239} {10496 @@@}}}
	D-^%NCC2 ok    {@! {composite {{brange 0 127}} {{brange 194 223} {brange 128 191}} {{byte 224} {brange 160 191} {brange 128 191}} {{byte 225} {brange 128 191} {brange 128 191}} {{byte 226} {brange 128 159} {brange 128 191}} {{byte 226} {brange 164 191} {brange 128 191}} {{brange 227 236} {brange 128 191} {brange 128 191}} {{byte 237} {brange 128 159} {brange 128 191}} {{brange 238 239} {brange 128 191} {brange 128 191}}}}
    }
    {^%named-class lu} {
	{}       error {Unable to reduce type (^%named-class (lu))}
	K-^%NCC  ok    {@q {^%named-class lu}}
	D-^%NCC1 ok    {@x {charclass {0 64} {91 96} {123 180} {182 191} 215 247 312 329 397 411 {426 427} {442 443} 446 {448 451} 496 545 {564 569} 597 600 602 {605 607} 610 612 615 {621 622} 624 {627 628} {630 636} {638 639} {641 642} {644 646} {653 657} {659 668} {671 836} {838 879} {884 885} {888 890} 894 {896 901} 903 907 909 912 930 944 1014 1020 {1154 1161} 1328 {1367 1376} {1415 4255} 4294 {4296 4300} {4302 5023} {5110 5111} {5118 7295} {7305 7544} {7546 7548} {7550 7679} {7830 7834} {7836 7837} 7839 {7958 7959} {7966 7967} {8006 8007} {8014 8016} 8018 8020 8022 8024 8026 8028 8030 {8062 8111} {8114 8119} {8124 8125} {8127 8135} {8140 8143} {8146 8151} {8156 8159} {8162 8164} {8166 8167} {8173 8183} {8188 8449} {8451 8454} {8456 8458} {8462 8463} {8467 8468} {8470 8472} {8478 8483} 8485 8487 8489 {8494 8495} {8500 8509} {8512 8516} {8518 8525} {8527 8578} {8581 11263} 11311 11359 11377 11380 {11383 11389} {11492 11498} {11503 11505} {11508 11519} 11558 {11560 11564} {11566 42559} {42606 42623} {42652 42785} {42800 42801} {42864 42872} {42888 42890} {42894 42895} {42900 42901} 42927 {42936 43858} {43860 43887} {43968 65312} {65339 65344} {65371 @@@}}}
	D-^%NCC2 ok    {@! {composite {{brange 0 64}} {{brange 91 96}} {{brange 123 127}} {{byte 194} {brange 128 180}} {{byte 194} {brange 182 191}} {{byte 195} {byte 151}} {{byte 195} {byte 183}} {{byte 196} {byte 184}} {{byte 197} {byte 137}} {{byte 198} {byte 141}} {{byte 198} {byte 155}} {{byte 198} {brange 170 171}} {{byte 198} {brange 186 187}} {{byte 198} {byte 190}} {{byte 199} {brange 128 131}} {{byte 199} {byte 176}} {{byte 200} {byte 161}} {{byte 200} {brange 180 185}} {{byte 201} {byte 149}} {{byte 201} {byte 152}} {{byte 201} {byte 154}} {{byte 201} {brange 157 159}} {{byte 201} {byte 162}} {{byte 201} {byte 164}} {{byte 201} {byte 167}} {{byte 201} {brange 173 174}} {{byte 201} {byte 176}} {{byte 201} {brange 179 180}} {{byte 201} {brange 182 188}} {{byte 201} {brange 190 191}} {{byte 202} {brange 129 130}} {{byte 202} {brange 132 134}} {{byte 202} {brange 141 145}} {{byte 202} {brange 147 156}} {{byte 202} {brange 159 191}} {{brange 203 204} {brange 128 191}} {{byte 205} {brange 128 132}} {{byte 205} {brange 134 175}} {{byte 205} {brange 180 181}} {{byte 205} {brange 184 186}} {{byte 205} {byte 190}} {{byte 206} {brange 128 133}} {{byte 206} {byte 135}} {{byte 206} {byte 139}} {{byte 206} {byte 141}} {{byte 206} {byte 144}} {{byte 206} {byte 162}} {{byte 206} {byte 176}} {{byte 207} {byte 182}} {{byte 207} {byte 188}} {{byte 210} {brange 130 137}} {{byte 212} {byte 176}} {{byte 213} {brange 151 160}} {{byte 214} {brange 135 191}} {{brange 215 223} {brange 128 191}} {{byte 224} {brange 160 191} {brange 128 191}} {{byte 225} {brange 128 129} {brange 128 191}} {{byte 225} {byte 130} {brange 128 159}} {{byte 225} {byte 131} {byte 134}} {{byte 225} {byte 131} {brange 136 140}} {{byte 225} {byte 131} {brange 142 191}} {{byte 225} {brange 132 141} {brange 128 191}} {{byte 225} {byte 142} {brange 128 159}} {{byte 225} {byte 143} {brange 182 183}} {{byte 225} {byte 143} {brange 190 191}} {{byte 225} {brange 144 177} {brange 128 191}} {{byte 225} {byte 178} {brange 137 191}} {{byte 225} {brange 179 180} {brange 128 191}} {{byte 225} {byte 181} {brange 128 184}} {{byte 225} {byte 181} {brange 186 188}} {{byte 225} {byte 181} {brange 190 191}} {{byte 225} {brange 182 183} {brange 128 191}} {{byte 225} {byte 186} {brange 150 154}} {{byte 225} {byte 186} {brange 156 157}} {{byte 225} {byte 186} {byte 159}} {{byte 225} {byte 188} {brange 150 151}} {{byte 225} {byte 188} {brange 158 159}} {{byte 225} {byte 189} {brange 134 135}} {{byte 225} {byte 189} {brange 142 144}} {{byte 225} {byte 189} {byte 146}} {{byte 225} {byte 189} {byte 148}} {{byte 225} {byte 189} {byte 150}} {{byte 225} {byte 189} {byte 152}} {{byte 225} {byte 189} {byte 154}} {{byte 225} {byte 189} {byte 156}} {{byte 225} {byte 189} {byte 158}} {{byte 225} {byte 189} {brange 190 191}} {{byte 225} {byte 190} {brange 128 175}} {{byte 225} {byte 190} {brange 178 183}} {{byte 225} {byte 190} {brange 188 189}} {{byte 225} {byte 190} {byte 191}} {{byte 225} {byte 191} {brange 128 135}} {{byte 225} {byte 191} {brange 140 143}} {{byte 225} {byte 191} {brange 146 151}} {{byte 225} {byte 191} {brange 156 159}} {{byte 225} {byte 191} {brange 162 164}} {{byte 225} {byte 191} {brange 166 167}} {{byte 225} {byte 191} {brange 173 183}} {{byte 225} {byte 191} {brange 188 191}} {{byte 226} {brange 128 131} {brange 128 191}} {{byte 226} {byte 132} {brange 128 129}} {{byte 226} {byte 132} {brange 131 134}} {{byte 226} {byte 132} {brange 136 138}} {{byte 226} {byte 132} {brange 142 143}} {{byte 226} {byte 132} {brange 147 148}} {{byte 226} {byte 132} {brange 150 152}} {{byte 226} {byte 132} {brange 158 163}} {{byte 226} {byte 132} {byte 165}} {{byte 226} {byte 132} {byte 167}} {{byte 226} {byte 132} {byte 169}} {{byte 226} {byte 132} {brange 174 175}} {{byte 226} {byte 132} {brange 180 189}} {{byte 226} {byte 133} {brange 128 132}} {{byte 226} {byte 133} {brange 134 141}} {{byte 226} {byte 133} {brange 143 191}} {{byte 226} {byte 134} {brange 128 130}} {{byte 226} {byte 134} {brange 133 191}} {{byte 226} {brange 135 175} {brange 128 191}} {{byte 226} {byte 176} {byte 175}} {{byte 226} {byte 177} {byte 159}} {{byte 226} {byte 177} {byte 177}} {{byte 226} {byte 177} {byte 180}} {{byte 226} {byte 177} {brange 183 189}} {{byte 226} {byte 179} {brange 164 170}} {{byte 226} {byte 179} {brange 175 177}} {{byte 226} {byte 179} {brange 180 191}} {{byte 226} {byte 180} {byte 166}} {{byte 226} {byte 180} {brange 168 172}} {{byte 226} {byte 180} {brange 174 191}} {{byte 226} {brange 181 191} {brange 128 191}} {{brange 227 233} {brange 128 191} {brange 128 191}} {{byte 234} {brange 128 152} {brange 128 191}} {{byte 234} {byte 153} {brange 174 191}} {{byte 234} {byte 154} {brange 156 191}} {{byte 234} {byte 155} {brange 128 191}} {{byte 234} {byte 156} {brange 128 161}} {{byte 234} {byte 156} {brange 176 177}} {{byte 234} {byte 157} {brange 176 184}} {{byte 234} {byte 158} {brange 136 138}} {{byte 234} {byte 158} {brange 142 143}} {{byte 234} {byte 158} {brange 148 149}} {{byte 234} {byte 158} {byte 175}} {{byte 234} {byte 158} {brange 184 191}} {{byte 234} {brange 159 172} {brange 128 191}} {{byte 234} {byte 173} {brange 128 146}} {{byte 234} {byte 173} {brange 148 175}} {{byte 234} {brange 175 191} {brange 128 191}} {{brange 235 236} {brange 128 191} {brange 128 191}} {{byte 237} {brange 128 159} {brange 128 191}} {{byte 238} {brange 128 191} {brange 128 191}} {{byte 239} {brange 128 187} {brange 128 191}} {{byte 239} {byte 188} {brange 128 160}} {{byte 239} {byte 188} {brange 187 191}} {{byte 239} {byte 189} {byte 128}} {{byte 239} {byte 189} {brange 155 191}} {{byte 239} {brange 190 191} {brange 128 191}}}}
    }
    range {
	{}     error {Unable to reduce incomplete literal (range ())}
	K-RAN  error {Unable to reduce incomplete literal (range ())}
	D-RAN1 error {Unable to reduce incomplete literal (range ())}
	D-RAN2 error {Unable to reduce incomplete literal (range ())}
    }
    {range 20 10} {
	{}     error {Unable to reduce empty literal (range (20 10))}
	K-RAN  error {Unable to reduce empty literal (range (20 10))}
	D-RAN1 error {Unable to reduce empty literal (range (20 10))}
	D-RAN2 error {Unable to reduce empty literal (range (20 10))}
    }
    {range 10 10} {
	{}     error {Unable to reduce empty literal (range (10 10))}
	K-RAN  error {Unable to reduce empty literal (range (10 10))}
	D-RAN1 error {Unable to reduce empty literal (range (10 10))}
	D-RAN2 error {Unable to reduce empty literal (range (10 10))}
    }
    {range 10 11} {
	{}     error {Unable to reduce type (range (10 11))}
	K-RAN  ok    {@q {range 10 11}}
	D-RAN1 ok    {@! {composite {{character 10}} {{character 11}}}}
	D-RAN2 ok    {@! {composite {{brange 10 11}}}}
    }
    %range {
	{}     error {Unable to reduce incomplete literal (%range ())}
	K-%RAN error {Unable to reduce incomplete literal (%range ())}
	D-%RAN error {Unable to reduce incomplete literal (%range ())}
    }
    {%range 20 10} {
	{}     error {Unable to reduce empty literal (%range (20 10))}
	K-%RAN error {Unable to reduce empty literal (%range (20 10))}
	D-%RAN error {Unable to reduce empty literal (%range (20 10))}
    }
    {%range 10 10} {
	{}     error {Unable to reduce empty literal (%range (10 10))}
	K-%RAN error {Unable to reduce empty literal (%range (10 10))}
	D-%RAN error {Unable to reduce empty literal (%range (10 10))}
    }
    {%range 97 99} {
	{}     error {Unable to reduce type (%range (97 99))}
	K-%RAN ok    {@q {%range 97 99}}
	D-%RAN ok    {@x {charclass {65 67} {97 99}}}
    }
    ^range {
	{}      error {Unable to reduce incomplete literal (^range ())}
	K-^RAN  error {Unable to reduce incomplete literal (^range ())}
	D-^RAN1 error {Unable to reduce incomplete literal (^range ())}
	D-^RAN2 error {Unable to reduce incomplete literal (^range ())}
    }
    {^range 0 @@@} {
	{}      error {Unable to reduce empty literal (^range (0 @@@))}
	K-^RAN  error {Unable to reduce empty literal (^range (0 @@@))}
	D-^RAN1 error {Unable to reduce empty literal (^range (0 @@@))}
	D-^RAN2 error {Unable to reduce empty literal (^range (0 @@@))}
    }
    {^range 0 10} {
	{}      error {Unable to reduce type (^range (0 10))}
	K-^RAN  ok    {@q {^range 0 10}}
	D-^RAN1 ok    {@x {range 11 @@@}}
	D-^RAN2 ok    {@! {composite {{brange 11 127}} {{brange 194 223} {brange 128 191}} {{byte 224} {brange 160 191} {brange 128 191}} {{brange 225 236} {brange 128 191} {brange 128 191}} {{byte 237} {brange 128 159} {brange 128 191}} {{brange 238 239} {brange 128 191} {brange 128 191}}}}
    }
    {^range 20 @@@} {
	{}      error {Unable to reduce type (^range (20 @@@))}
	K-^RAN  ok    {@q {^range 20 @@@}}
	D-^RAN1 ok    {@x {range 0 19}}
	D-^RAN2 ok    {@! {composite {{brange 0 19}}}}
    }
    {^range 10 20} {
	{}      error {Unable to reduce type (^range (10 20))}
	K-^RAN  ok    {@q {^range 10 20}}
	D-^RAN1 ok    {@x {charclass {0 9} {21 @@@}}}
	D-^RAN2 ok    {@! {composite {{brange 0 9}} {{brange 21 127}} {{brange 194 223} {brange 128 191}} {{byte 224} {brange 160 191} {brange 128 191}} {{brange 225 236} {brange 128 191} {brange 128 191}} {{byte 237} {brange 128 159} {brange 128 191}} {{brange 238 239} {brange 128 191} {brange 128 191}}}}
    }
    ^character {
	{}     error {Unable to reduce incomplete literal (^character ())}
	K-^CHR error {Unable to reduce incomplete literal (^character ())}
	D-^CHR error {Unable to reduce incomplete literal (^character ())}
    }
    {^character 300} {
	{}     error {Unable to reduce type (^character (300))}
	K-^CHR ok    {@q {^character 300}}
	D-^CHR ok    {@x {charclass {0 299} {301 @@@}}}
	!----- ----- { using 2 ranges,    -^- 300 excluded }
    }
} {
    # Skip annotations
    if {[string match !* $literal]} { puts XXX.reduce1.$literal ; continue }

    # Fix placeholder for semi-dynamic upper unicode limit
    set literal [string map [list @@@ [marpa unicode max]] $literal]

    incr k
    set j 0
    foreach {rules code result} $toexpect {
	# Skip annotations
	if {[string match !* $rules]} continue ;#{ puts XXX.reduce1.$literal.$rules ; continue }
	if {[string match X* $rules]} { puts XXX.reduce1.$literal.$rules ; continue }

	incr j

	set result [string map $map [string trim $result]]
	set result [join [lmap line [split $result \n] {
	    string trim $line
	}] \n]

	test marpa-slif-literal-reduce1-2.$k.$j "reduce1 $code ($literal) $rules" -setup {
	    set state [log STATE] ; /trace STATE
	} -body {
	    marpa::slif::literal reduce1 <symbol> $literal $rules $state
	    string trim [logged "\n"]
	} -cleanup {
	    catch { logged }
	    unset state
	} -returnCodes $code -result $result
    }
}

# # ## ### ##### ######## ############# #####################
## rstate - state object for reducer
## [ok] new, create
## [ok] work?
## [ok] take
## [ok] place
## [ok] queue
## [ok] symbolize
## [ok] results

# # ## ### ##### ######## ############# #####################
## rstate constructor

test marpa-slif-literal-rstate-cons-1.0 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate new
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.1 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate new W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.2 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate create R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-1.3 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate create R W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-2.0 {rstate, cons, auto} -body {
    set r [marpa::slif::literal rstate new {}]
} -cleanup {
    $r destroy
    unset r
} -match glob -result ::oo::Obj*

test marpa-slif-literal-rstate-cons-2.1 {rstate, cons, explicitly named} -body {
    marpa::slif::literal rstate create R {}
} -cleanup {
    R destroy
} -result ::R

# # ## ### ##### ######## ############# #####################
## rstate work?

test marpa-slif-literal-rstate-work?-1.0 {rstate, work?, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work? X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R work?"}

test marpa-slif-literal-rstate-work?-2.0 {rstate, work?, none} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work?
} -cleanup {
    R destroy
} -result 0

test marpa-slif-literal-rstate-work?-2.1 {rstate, work?, some} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
} -body {
    R work?
} -cleanup {
    R destroy
} -result 2

# # ## ### ##### ######## ############# #####################
## rstate take

test marpa-slif-literal-rstate-take-1.0 {rstate, take, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R take"}

test marpa-slif-literal-rstate-take-2.0 {rstate, take, nothing} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take
} -cleanup {
    R destroy
} -returnCodes error -result {No work available}

test marpa-slif-literal-rstate-take-2.1 {rstate, take, last (stack)} -setup {
    marpa::slif::literal rstate create R {
	B {string 65 66 67}
	A {character 78}
    }
} -body {
    R take
} -cleanup {
    R destroy
} -result {A {character 78}}

# # ## ### ##### ######## ############# #####################
## rstate place

test marpa-slif-literal-rstate-place-1.0 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.1 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.2 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.3 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.4 {rstate, place, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-2.0.0 {rstate, place (literal), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.0.1 {rstate, place (literal), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
    R results
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-place-2.1.0 {rstate, place (literal), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.1.1 {rstate, place (literal), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-place-2.2.0 {rstate, place (composite), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.2.1 {rstate, place (composite), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results]
} -cleanup {
    R destroy
} -result {0 --- {S {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}}}

test marpa-slif-literal-rstate-place-2.3.0 {rstate, place (composite), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.3.1 {rstate, place (composite), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results] --- [R take] --- [R take]
} -cleanup {
    R destroy
} -result {2 --- {S {composite @CHR:<-> @CHR:<.>}} --- {@CHR:<.> {character 46}} --- {@CHR:<-> {character 45}}}

# # ## ### ##### ######## ############# #####################
## rstate queue

test marpa-slif-literal-rstate-queue-1.0 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.1 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.2 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.3 {rstate, queue, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-2.0.0 {rstate, queue, results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.0.1 {rstate, queue, results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
    R results
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-queue-2.1.0 {rstate, queue, work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.1.1 {rstate, queue, work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

# # ## ### ##### ######## ############# #####################
## rstate results

test marpa-slif-literal-rstate-results-1.0 {rstate, results, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R results X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R results"}

test marpa-slif-literal-rstate-results-2.0 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # No results. Because this is all in the work-queue.
} -body {
    R results
} -cleanup {
    R destroy
} -result {}

test marpa-slif-literal-rstate-results-2.1 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # Shift the initial work queue over into results, unchanged.
    R queue done {*}[R take]
    R queue done {*}[R take]
} -body {
    R results
} -cleanup {
    R destroy
} -result {A {character 12} B {string 65 66 67}}

# # ## ### ##### ######## ############# #####################
## symbol - Generate a symbol for a literal from its representation.

test marpa-slif-literal-symbol-1.0 {symbol, wrong args, not enough} -body {
    marpa::slif::literal symbol
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

test marpa-slif-literal-symbol-1.1 {symbol, wrong args, too many} -body {
    marpa::slif::literal symbol LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

set k 0
foreach {literal symbol} {
    {%named-class braille}                        @%NCC:<[:braille:]>
    {%string 65 45}                               @%STR:<A->
    {^%named-class braille}                       @^%NCC:<[:braille:]>
    {^character 45}                               @^CHR:<->
    {^character 97}                               @^CHR:<a>
    {^charclass 45 %braille}                      @^CLS:<-[:%braille:]>
    {^charclass 45 {65 70} {97 102} %braille}     @^CLS:<-A-Fa-f[:%braille:]>
    {^charclass 45 {65 70} {97 102}}              @^CLS:<-A-Fa-f>
    {^charclass 45 {97 102} braille}              @^CLS:<-a-f[:braille:]>
    {^charclass 45 {97 102}}                      @^CLS:<-a-f>
    {^charclass 65 97 %braille}                   @^CLS:<Aa[:%braille:]>
    {^charclass 65 97}                            @^CLS:<Aa>
    {^charclass 97 braille}                       @^CLS:<a[:braille:]>
    {^charclass {45 47} %braille}                 @^CLS:<--/[:%braille:]>
    {^charclass {45 47} 65 97}                    @^CLS:<--/Aa>
    {^charclass {65 70} {97 102} %braille}        @^CLS:<A-Fa-f[:%braille:]>
    {^charclass {65 70} {97 102}}                 @^CLS:<A-Fa-f>
    {^charclass {97 102} braille}                 @^CLS:<a-f[:braille:]>
    {^named-class braille}                        @^NCC:<[:braille:]>
    {^range 97 102}                               @^RAN:<af>
    {character 45}                                @CHR:<->
    {character 97}                                @CHR:<a>
    {charclass 45 %braille}                       @CLS:<-[:%braille:]>
    {charclass 45 {65 70} {97 102} %braille}      @CLS:<-A-Fa-f[:%braille:]>
    {charclass 45 {65 70} {97 102}}               @CLS:<-A-Fa-f>
    {charclass 45 {97 102} braille}               @CLS:<-a-f[:braille:]>
    {charclass 45 {97 102}}                       @CLS:<-a-f>
    {charclass 65 97 %braille}                    @CLS:<Aa[:%braille:]>
    {charclass 65 97}                             @CLS:<Aa>
    {charclass 97 braille}                        @CLS:<a[:braille:]>
    {charclass {45 47} %braille}                  @CLS:<--/[:%braille:]>
    {charclass {45 47} 65 97}                     @CLS:<--/Aa>
    {charclass {65 70} {97 102} %braille}         @CLS:<A-Fa-f[:%braille:]>
    {charclass {65 70} {97 102}}                  @CLS:<A-Fa-f>
    {charclass {97 102} braille}                  @CLS:<a-f[:braille:]>
    {named-class braille}                         @NCC:<[:braille:]>
    {range 97 102}                                @RAN:<af>
    {string 97 45}                                @STR:<a->
} {
    incr k
    test marpa-slif-literal-symbol-2.$k "symbol, $literal" -body {
	marpa::slif::literal symbol $literal
    } -result $symbol
}

# # ## ### ##### ######## ############# #####################
## parse - Parse a literal string into a normalized internal representation.

test marpa-slif-literal-parse-1.0 {parse, wrong args, not enough} -body {
    marpa::slif::literal parse
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

test marpa-slif-literal-parse-1.2 {parse, wrong args, too many} -body {
    marpa::slif::literal parse LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

set k 0
foreach {rule litstring res} {
    N01 {'a'}                        {character 97}
    N02 {'a-'}                       {string 97 45}

    N03 {'a':i}                      {charclass 65 97}
    N03 {'-':i}                      {character 45}
    N04 {'a-':i}                     {%string 65 45}

    N05 {[a]}                        {character 97}
    N06 {[a-f]}                      {range 97 102}
    N07 {[[:braille:]]}              {named-class braille}
    N08 {[[:braille:]a]}             {charclass 97 braille}
    N08 {[\-a-f]}                    {charclass 45 {97 102}}
    N08 {[a-f[:braille:]]}           {charclass {97 102} braille}
    N08 {[a-f[:braille:]\-]}         {charclass 45 {97 102} braille}

    N09 {[a]:i}                      {charclass 65 97}
    N09 {[\-]:i}                     {character 45}
    N10 {[a-f]:i}                    {charclass {65 70} {97 102}}
    N11 {[[:braille:]]:i}            {%named-class braille}
    N12 {[a[:braille:]]:i}           {charclass 65 97 %braille}
    N12 {[[:braille:]\-]:i}          {charclass 45 %braille}
    N12 {[a-f\-]:i}                  {charclass 45 {65 70} {97 102}}
    N12 {[\x2D-/a]:i}                {charclass {45 47} 65 97}
    N12 {[[:braille:]a-f]:i}         {charclass {65 70} {97 102} %braille}
    N12 {[\055-/[:braille:]]:i}      {charclass {45 47} %braille}
    N12 {[\055[:braille:]a-f]:i}     {charclass 45 {65 70} {97 102} %braille}
	                 
    N13 {[^a]}                       {^character 97}
    N14 {[^abcdef]}                  {^range 97 102}
    N15 {[^[:braille:]]}             {^named-class braille}
    N16 {[^[:braille:]a]}            {^charclass 97 braille}
    N16 {[^a-c\055d-f]}              {^charclass 45 {97 102}}
    N16 {[^d-f[:braille:]a-e]}       {^charclass {97 102} braille}
    N16 {[^a-c\055[:braille:]b-f]}  {^charclass 45 {97 102} braille}
	                
    N17 {[^a]:i}                     {^charclass 65 97}
    N17 {[^\x2d]:i}                  {^character 45}
    N18 {[^a-f]:i}                   {^charclass {65 70} {97 102}}
    N19 {[^[:braille:]]:i}           {^%named-class braille}
    N20 {[^[:braille:]a]:i}          {^charclass 65 97 %braille}
    N20 {[^[:braille:]\055]:i}       {^charclass 45 %braille}
    N20 {[^a-c\055b-f]:i}            {^charclass 45 {65 70} {97 102}}
    N20 {[^\055\056\057a]:i}         {^charclass {45 47} 65 97}
    N20 {[^[:braille:]a-f]:i}        {^charclass {65 70} {97 102} %braille}
    N20 {[^[:braille:]\--/]:i}       {^charclass {45 47} %braille}
    N20 {[^\055abcdef[:braille:]]:i} {^charclass 45 {65 70} {97 102} %braille}
} {
    incr k
    test marpa-slif-literal-parse-2.$k "parse, $rule, $litstring" -body {
	marpa::slif::literal parse $litstring
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## norm - Normalize literal without deconstructing it into multiple pieces.
##        Keeps named classes, ranges

test marpa-slif-literal-norm-1.0 {norm, wrong args, not enough} -body {
    marpa::slif::literal norm
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

test marpa-slif-literal-norm-1.2 {norm, wrong args, too many} -body {
    marpa::slif::literal norm LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

set k 0
foreach {rule literal res} {
    N01 {string 97}             {character 97}
    N02 {string 97 45}          --

    N03 {%string 97}            {charclass 65 97}
    N03 {%string 45}            {character 45}
    N04 {%string 65 45}         --

    N05 {charclass 97}                    {character 97}
    N06 {charclass {97 102}}              {range 97 102}
    N07 {charclass braille}               {named-class braille}
    N08 {charclass 97 braille}            --mix:char,named
    N08 {charclass 45 {97 102}}           --mix:char,range
    N08 {charclass {97 102} braille}      --mix:range,named
    N08 {charclass 45 {97 102} braille}   --mix:char,range,named

    N09 {%charclass 97}                   {charclass 65 97}
    N09 {%charclass 45}                   {character 45}
    N10 {%charclass {97 102}}             {charclass {65 70} {97 102}}
    N11 {%charclass braille}              {%named-class braille}
    N12 {%charclass 97 braille}           {charclass 65 97 %braille}
    N12 {%charclass 45 braille}           {charclass 45 %braille}
    N12 {%charclass 45 {97 102}}          {charclass 45 {65 70} {97 102}}
    N12 {%charclass {45 47} 97}           {charclass {45 47} 65 97}
    N12 {%charclass {97 102} braille}     {charclass {65 70} {97 102} %braille}
    N12 {%charclass {45 47} braille}      {charclass {45 47} %braille}
    N12 {%charclass 45 {97 102} braille}  {charclass 45 {65 70} {97 102} %braille}

    N13 {^charclass 97}                   {^character 97}
    N14 {^charclass {97 102}}             {^range 97 102}
    N15 {^charclass braille}              {^named-class braille}
    N16 {^charclass 97 braille}           --mix:char,named
    N16 {^charclass 45 {97 102}}          --mix:char,range
    N16 {^charclass {97 102} braille}     --mix:range,named
    N16 {^charclass 45 {97 102} braille}  --mix:char,range,named

    N17 {^%charclass 97}                  {^charclass 65 97}
    N17 {^%charclass 45}                  {^character 45}
    N18 {^%charclass {97 102}}            {^charclass {65 70} {97 102}}
    N19 {^%charclass braille}             {^%named-class braille}
    N20 {^%charclass 97 braille}          {^charclass 65 97 %braille}
    N20 {^%charclass 45 braille}          {^charclass 45 %braille}
    N20 {^%charclass 45 {97 102}}         {^charclass 45 {65 70} {97 102}}
    N20 {^%charclass {45 47} 97}          {^charclass {45 47} 65 97}
    N20 {^%charclass {97 102} braille}    {^charclass {65 70} {97 102} %braille}
    N20 {^%charclass {45 47} braille}     {^charclass {45 47} %braille}
    N20 {^%charclass 45 {97 102} braille} {^charclass 45 {65 70} {97 102} %braille}
} {
    incr k
    if {[string match --* $res]} { set res $literal }
    test marpa-slif-literal-norm-2.$k "norm, $rule, $literal" -body {
	marpa::slif::literal norm $literal
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## eltype - Determine type of charclass element

test marpa-slif-literal-eltype-1.0 {eltype, wrong args, not enough} -body {
    marpa::slif::literal eltype
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

test marpa-slif-literal-eltype-1.2 {eltype, wrong args, too many} -body {
    marpa::slif::literal eltype CCELEMENT X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

set k 0
foreach {ccelement res} {
    37      character
    {48 57} range
    alnum   named-class
} {
    incr k
    test marpa-slif-literal-eltype-2.$k "eltype, $ccelement" -body {
	marpa::slif::literal eltype $ccelement
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccunfold - Case-expand a charclass to contain original and case-equivalent characters.

test marpa-slif-literal-ccunfold-1.0 {ccunfold, wrong args, not enough} -body {
    marpa::slif::literal ccunfold
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

test marpa-slif-literal-ccunfold-1.2 {ccunfold, wrong args, too many} -body {
    marpa::slif::literal ccunfold DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

set k 0
foreach {data res} {
    {37 {48 57} {97 122} alnum braille}
    {37 {48 57} {65 90} {97 122} {304 305} 383 8490 %alnum %braille}
} {
    incr k
    test marpa-slif-literal-ccunfold-2.$k "ccunfold, $data" -body {
	marpa::slif::literal ccunfold $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccsplit - Split char class data into codes/ranges vs named

test marpa-slif-literal-ccsplit-1.0 {ccsplit, wrong args, not enough} -body {
    marpa::slif::literal ccsplit
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

test marpa-slif-literal-ccsplit-1.2 {ccsplit, wrong args, too many} -body {
    marpa::slif::literal ccsplit DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

set k 0
foreach {data res} {
    {37 {48 57} {97 122} alnum braille}    {{37 {48 57} {97 122}} {alnum braille}}
} {
    incr k
    test marpa-slif-literal-ccsplit-2.$k "ccsplit, $data" -body {
	marpa::slif::literal ccsplit $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode - Generate internal rep for incoming typed literal

test marpa-slif-literal-decode-1.0 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.1 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode TYPE
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.2 {decode, wrong args, too many} -body {
    marpa::slif::literal decode TYPE LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-2.0 {decode, bogus type} -body {
    marpa::slif::literal decode bogus abcdef
} -returnCodes error -result {Unable to decode bogus type "bogus"}

#       a   b   c   d   e   f   g   h   i   j   k   l   m
# a-m = 97  98  99  100 101 102 103 104 105 106 107 108 109
#       n   o   p   q   r   s   t   u   v   w   x   y   z
# n-z = 110 111 112 113 114 115 116 117 118 119 120 121 122

set k 0
foreach {lit rclass rstring} {
    abcdef                 {{97 102}}            {97 98 99 100 101 102}
    a-z                    {{97 122}}            {97 45 122}
    {[:braille:]}          {braille}             {91 58 98 114 97 105 108 108 101 58 93}
    --z                    {{45 122}}            {45 45 122}
    %--                    {{37 45}}             {37 45 45}
    a-z0-9%                {37 {48 57} {97 122}} {97 45 122 48 45 57 37}
    {0-9[:alnum:]}         {{48 57} alnum}       {48 45 57 91 58 97 108 110 117 109 58 93}
    {[:braille:][:alnum:]} {alnum braille}       {91 58 98 114 97 105 108 108 101 58 93 91 58 97 108 110 117 109 58 93}
} {
    incr k

    test marpa-slif-literal-decode-2.$k.1 "decode, string $lit" -body {
	marpa::slif::literal decode string $lit
    } -result [linsert $rstring 0 string]

    # %string is special, as it converts to primary codepoints.
    # Thus, no looping, but a separate test case.
    test marpa-slif-literal-decode-2.$k.2 "decode, %string $lit" -body {
	marpa::slif::literal decode %string $lit
    } -result [linsert [marpa unicode fold/c $rstring] 0 %string]

    set j 0
    foreach type {
	charclass %charclass ^charclass ^%charclass
    } {
	incr j
	test marpa-slif-literal-decode-3.$k.$j "decode, $type $lit" -body {
	    marpa::slif::literal decode $type $lit
	} -result [linsert $rclass 0 $type]
    }
}

# # ## ### ##### ######## ############# #####################
## decode-class - Generate internal rep for incoming character class

test marpa-slif-literal-decode-class-1.0 {decode-class, wrong args, not enough} -body {
    marpa::slif::literal decode-class
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

test marpa-slif-literal-decode-class-1.1 {decode-class, wrong args, too many} -body {
    marpa::slif::literal decode-class LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

set k 0
foreach {lit res} {
    abcdef                 {{97 102}}
    a-z                    {{97 122}}
    {[:braille:]}          {braille}
    --z                    {{45 122}}
    %--                    {{37 45}}
    a-z0-9%                {37 {48 57} {97 122}}
    {0-9[:alnum:]}         {{48 57} alnum}
    {[:braille:][:alnum:]} {alnum braille}
} {
    incr k
    test marpa-slif-literal-decode-class-2.$k "decode-class, $lit" -body {
	marpa::slif::literal decode-class $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode-string - Generate internal rep for incoming string
##                 ATTENTION: The `type` information is upvar'd from
##                 the calling scope, normally `decode`.

test marpa-slif-literal-decode-string-1.0 {decode-string, wrong args, not enough} -body {
    marpa::slif::literal decode-string
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

test marpa-slif-literal-decode-string-1.1 {decode-string, wrong args, too many} -body {
    marpa::slif::literal decode-string LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

set k 0
foreach {lit type res} {
    abcdef  string  {97 98 99 100 101 102}
    abcdef  %string {65 66 67 68 69 70}
} {
    incr k
    test marpa-slif-literal-decode-string-2.$k "decode-string, $lit" -body {
	# `type` is upvar'd in.
	marpa::slif::literal decode-string $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## type - Determine type of incoming literal+nocase (string, charclass)

test marpa-slif-literal-type-1.0 {type, wrong args, not enough} -body {
    marpa::slif::literal type
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.1 {type, wrong args, not enough} -body {
    marpa::slif::literal type LITSTRING
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.2 {type, wrong args, too many} -body {
    marpa::slif::literal type LITSTRING NOCASE X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-2.0 {type, bogus} -body {
    marpa::slif::literal type {abcde} 0
} -returnCodes error -result {Unable to determine type of literal "abcde"}

set k 0
foreach {lit nocase res} {
    "'abcdef'"    0 {string abcdef}
    "\[abcdef\]"  0 {charclass abcdef}
    "\[^abcdef\]" 0 {^charclass abcdef}
    "'abcdef'"    1 {%string abcdef}
    "\[abcdef\]"  1 {%charclass abcdef}
    "\[^abcdef\]" 1 {^%charclass abcdef}
} {
    incr k
    test marpa-slif-literal-type-2.$k "type, $lit" -body {
	marpa::slif::literal type $lit $nocase
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## unescape - Deal with Tcl \-escape in the literal, convert to regular characters.
## To handle
## - \[nrtfv\']-] (more ? ab...) CHECK Tcl docs
## - \xHHHHHHHHHH (hexes)
## - \OOO (octals)
## - \uHHHH (unicodes)

test marpa-slif-literal-unescape-1.0 {unescape, wrong args, not enough} -body {
    marpa::slif::literal unescape
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}

test marpa-slif-literal-unescape-1.1 {unescape, wrong args, too many} -body {
    marpa::slif::literal unescape LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}

set k 0
foreach {lit res} {
    "\\n\\r\\t\\f\\v\\a\\'\\\]\\-\\\\"  "\n\r\t\f\v\a'\]-\\"
    "\\377"                             "\377"
    "\xFFFFFFFFFFFF"                    "\xFF"
    "\\u2202"                           "\u2202"
    "abcdef"                            "abcdef"
} {
    incr k
    test marpa-slif-literal-unescape-2.$k "unescape, $lit" -body {
	marpa::slif::literal unescape $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## tags - Strips tags from the literal. Currently only :i, :ic, both
##        indicating a case-insensitive literal

test marpa-slif-literal-tags-1.0 {tags, wrong args, not enough} -body {
    marpa::slif::literal tags
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

test marpa-slif-literal-tags-1.1 {tags, wrong args, too many} -body {
    marpa::slif::literal tags LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

set k 0
foreach {lit res} {
    foo:i  {foo 1}
    foo:ic {foo 1}
    foo:x  {foo:x 0}
    fox    {fox 0}
} {
    incr k
    test marpa-slif-literal-tags-2.$k "tags, $lit" -body {
	marpa::slif::literal tags $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
cleanupTests
