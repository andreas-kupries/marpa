# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017-2018 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::slif::literal

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO

kt local   support marpa::util
kt local   testing marpa::slif::literal

# # ## ### ##### ######## ############# #####################

kt source support/common.tcl
kt source support/dirs.tcl
kt source support/textutils.tcl
kt source support/tcl-core.tcl
kt source support/literals.tcl

# # ## ### ##### ######## ############# #####################

kt source cases/ccranges.tcl
kt source cases/lit-symbol.tcl
kt source cases/lit-parse.tcl
kt source cases/lit-norm.tcl
kt source cases/lit-decode.tcl
kt source cases/lit-unescape.tcl
kt source cases/lit-reduce-full.tcl
kt source cases/lit-reduce-step.tcl

# # ## ### ##### ######## ############# #####################
## [ok] symbol        \
## [ok] parse         / API (normalization)
## [ok] norm          \
## [ok] eltype        | Helpers. Exposed for testing internals
## [ok] ccunfold      | (before testing the visible API)
## [ok] ccsplit       |   |
## [ok] decode        \___/
## [ok] decode-string /
## [ok] decode-class  |
## [ok] type          |
## [ok] unescape      |
## [ok] tags
#
## [ok] r2container \
## [ok] reduce      / API (reduction)
## [ok] reduce1     \
## [ok] rstate       > Helpers. Exposed for testing the internals.
## [ok] ccranges    /

# # ## ### ##### ######## ############# #####################
## ccranges - Expand a mixed charclass into pure set of ranges

test marpa-slif-literal-ccranges-1.0 {ccranges, wrong args, not enough} -body {
    marpa::slif::literal ccranges
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccranges data"}

test marpa-slif-literal-ccranges-1.1 {ccranges, wrong args, too many} -body {
    marpa::slif::literal ccranges D X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccranges data"}

testcases k {cc ranges} [cc-ranges] {
    test marpa-slif-literal-ccranges-2.$k "ccranges, $cc" -body {
	marpa::slif::literal ccranges $cc
    } -result $ranges
}

# # ## ### ##### ######## ############# #####################
## r2container - Transfer a reduction result into a container

test marpa-slif-literal-r2container-1.0 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-1.1 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-1.2 {r2container, wrong args, too many} -body {
    marpa::slif::literal r2container W C X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-2.0 {r2container, nothing} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {} $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result {}

test marpa-slif-literal-r2container-2.1 {r2container, all cases} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {{
	C {composite {A} {B}}
	S {composite {A B}}
	A {character 65}
	B {character 66}
    } {}} $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result [norm-trace [trdir r2c21]]

# # ## ### ##### ######## ############# #####################
## reduce - reduction to minimum

test marpa-slif-literal-reduce-1.0 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.1 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.2 {reduce, wrong args, too many} -body {
    marpa::slif::literal reduce W R X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

testcases k {literal subcases} [lit-reduce-full] {
    testcases j {rules result} $subcases {
	lassign $result code expected
	
	test marpa-slif-literal-reduce-2.$k.$j "reduce $code ($literal) $rules, worklist" -body {
	    F [lindex [marpa::slif::literal reduce [list <symbol> $literal] $rules] 0]
	    # Access worklist, ignore the aliases, supposed to be empty
	} -returnCodes $code -result $expected

	if {$code eq "error"} continue

	test marpa-slif-literal-reduce-3.$k.$j "reduce $code ($literal) $rules, aliases" -body {
	    lindex [marpa::slif::literal reduce [list <symbol> $literal] $rules] 1
	    # Access aliases, always empty
	} -result {}
    }
}

# # ## ### ##### ######## ############# #####################
## reduce1 - single reduction step

test marpa-slif-literal-reduce1-1.0 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.1 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.2 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.3 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.4 {reduce1, wrong args, too many} -body {
    marpa::slif::literal reduce1 S L R S X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

testcases k {literal subcases} [lit-reduce-step] {
    testcases j {rules result} $subcases {
	lassign $result code expected

	test marpa-slif-literal-reduce1-2.$k.$j "reduce1 $code ($literal) $rules" -setup {
	    set state [log STATE] ; /trace STATE
	} -body {
	    marpa::slif::literal reduce1 <symbol> $literal $rules $state
	    string trim [logged "\n"]
	} -cleanup {
	    catch { logged }
	    unset state
	} -returnCodes $code -result $expected
    }
}

# # ## ### ##### ######## ############# #####################
## rstate - state object for reducer
## [ok] new, create
## [ok] work?
## [ok] take
## [ok] place
## [ok] queue
## [ok] symbolize
## [ok] results

# # ## ### ##### ######## ############# #####################
## rstate constructor

test marpa-slif-literal-rstate-cons-1.0 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate new
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.1 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate new W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.2 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate create R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-1.3 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate create R W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-2.0 {rstate, cons, auto} -body {
    set r [marpa::slif::literal rstate new {}]
} -cleanup {
    $r destroy
    unset r
} -match glob -result ::oo::Obj*

test marpa-slif-literal-rstate-cons-2.1 {rstate, cons, explicitly named} -body {
    marpa::slif::literal rstate create R {}
} -cleanup {
    R destroy
} -result ::R

# # ## ### ##### ######## ############# #####################
## rstate work?

test marpa-slif-literal-rstate-work?-1.0 {rstate, work?, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work? X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R work?"}

test marpa-slif-literal-rstate-work?-2.0 {rstate, work?, none} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work?
} -cleanup {
    R destroy
} -result 0

test marpa-slif-literal-rstate-work?-2.1 {rstate, work?, some} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
} -body {
    R work?
} -cleanup {
    R destroy
} -result 2

# # ## ### ##### ######## ############# #####################
## rstate take

test marpa-slif-literal-rstate-take-1.0 {rstate, take, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R take"}

test marpa-slif-literal-rstate-take-2.0 {rstate, take, nothing} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take
} -cleanup {
    R destroy
} -returnCodes error -result {No work available}

test marpa-slif-literal-rstate-take-2.1 {rstate, take, last (stack)} -setup {
    marpa::slif::literal rstate create R {
	B {string 65 66 67}
	A {character 78}
    }
} -body {
    R take
} -cleanup {
    R destroy
} -result {A {character 78}}

# # ## ### ##### ######## ############# #####################
## rstate place

test marpa-slif-literal-rstate-place-1.0 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.1 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.2 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.3 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.4 {rstate, place, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-2.0.0 {rstate, place (literal), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.0.1 {rstate, place (literal), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
    R results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-place-2.1.0 {rstate, place (literal), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.1.1 {rstate, place (literal), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-place-2.2.0 {rstate, place (composite), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.2.1 {rstate, place (composite), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results]
} -cleanup {
    R destroy
} -result {0 --- {{S {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}} {}}}

test marpa-slif-literal-rstate-place-2.3.0 {rstate, place (composite), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.3.1 {rstate, place (composite), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results] --- [R take] --- [R take]
} -cleanup {
    R destroy
} -result {2 --- {{S {composite @CHR:<-> @CHR:<.>}} {}} --- {@CHR:<.> {character 46}} --- {@CHR:<-> {character 45}}}

# # ## ### ##### ######## ############# #####################
## rstate queue

test marpa-slif-literal-rstate-queue-1.0 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.1 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.2 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.3 {rstate, queue, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-2.0.0 {rstate, queue, results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.0.1 {rstate, queue, results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
    R results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-queue-2.1.0 {rstate, queue, work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.1.1 {rstate, queue, work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

# # ## ### ##### ######## ############# #####################
## rstate results

test marpa-slif-literal-rstate-results-1.0 {rstate, results, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R results X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R results"}

test marpa-slif-literal-rstate-results-2.0 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # Empty results. Because this is all in the work-queue.
} -body {
    R results
} -cleanup {
    R destroy
} -result {{} {}}

test marpa-slif-literal-rstate-results-2.1 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # Shift the initial work queue over into results, unchanged.
    R queue done {*}[R take]
    R queue done {*}[R take]
} -body {
    R results
} -cleanup {
    R destroy
} -result {{A {character 12} B {string 65 66 67}} {}}

# # ## ### ##### ######## ############# #####################
## symbol - Generate a symbol for a literal from its representation.

test marpa-slif-literal-symbol-1.0 {symbol, wrong args, not enough} -body {
    marpa::slif::literal symbol
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

test marpa-slif-literal-symbol-1.1 {symbol, wrong args, too many} -body {
    marpa::slif::literal symbol LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

testcases k {literal symbol} [lit-symbol] {
    test marpa-slif-literal-symbol-2.$k "symbol, $literal" -body {
	marpa::slif::literal symbol $literal
    } -result $symbol
}

# # ## ### ##### ######## ############# #####################
## parse - Parse a literal string into a normalized internal representation.

test marpa-slif-literal-parse-1.0 {parse, wrong args, not enough} -body {
    marpa::slif::literal parse
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

test marpa-slif-literal-parse-1.2 {parse, wrong args, too many} -body {
    marpa::slif::literal parse LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

testcases k {rule litstring res} [lit-parse] {
    test marpa-slif-literal-parse-2.$k "parse, $rule, $litstring" -body {
	marpa::slif::literal parse $litstring
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## norm - Normalize literal without deconstructing it into multiple pieces.
##        Keeps named classes, ranges

test marpa-slif-literal-norm-1.0 {norm, wrong args, not enough} -body {
    marpa::slif::literal norm
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

test marpa-slif-literal-norm-1.2 {norm, wrong args, too many} -body {
    marpa::slif::literal norm LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

testcases k {rule literal res} [lit-norm] {
    if {[string match --* $res]} { set res $literal }
    test marpa-slif-literal-norm-2.$k "norm, $rule, $literal" -body {
	marpa::slif::literal norm $literal
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## eltype - Determine type of charclass element

test marpa-slif-literal-eltype-1.0 {eltype, wrong args, not enough} -body {
    marpa::slif::literal eltype
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

test marpa-slif-literal-eltype-1.2 {eltype, wrong args, too many} -body {
    marpa::slif::literal eltype CCELEMENT X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

testcases k {ccelement res} {
    37      character
    {48 57} range
    alnum   named-class
} {
    test marpa-slif-literal-eltype-2.$k "eltype, $ccelement" -body {
	marpa::slif::literal eltype $ccelement
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccunfold - Case-expand a charclass to contain original and case-equivalent characters.

test marpa-slif-literal-ccunfold-1.0 {ccunfold, wrong args, not enough} -body {
    marpa::slif::literal ccunfold
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

test marpa-slif-literal-ccunfold-1.2 {ccunfold, wrong args, too many} -body {
    marpa::slif::literal ccunfold DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

testcases k {data res} {
    {37 {48 57} {97 122} alnum braille}
    {37 {48 57} {65 90} {97 122} {304 305} 383 8490 %alnum %braille}
} {
    test marpa-slif-literal-ccunfold-2.$k "ccunfold, $data" -body {
	marpa::slif::literal ccunfold $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccsplit - Split char class data into codes/ranges vs named

test marpa-slif-literal-ccsplit-1.0 {ccsplit, wrong args, not enough} -body {
    marpa::slif::literal ccsplit
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

test marpa-slif-literal-ccsplit-1.2 {ccsplit, wrong args, too many} -body {
    marpa::slif::literal ccsplit DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

testcases k {data res} {
    {37 {48 57} {97 122} alnum braille}
    {{37 {48 57} {97 122}} {alnum braille}}
} {
    test marpa-slif-literal-ccsplit-2.$k "ccsplit, $data" -body {
	marpa::slif::literal ccsplit $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode - Generate internal rep for incoming typed literal

test marpa-slif-literal-decode-1.0 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.1 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode TYPE
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.2 {decode, wrong args, too many} -body {
    marpa::slif::literal decode TYPE LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-2.0 {decode, bogus type} -body {
    marpa::slif::literal decode bogus abcdef
} -returnCodes error -result {Unable to decode bogus type "bogus"}

#       a   b   c   d   e   f   g   h   i   j   k   l   m
# a-m = 97  98  99  100 101 102 103 104 105 106 107 108 109
#       n   o   p   q   r   s   t   u   v   w   x   y   z
# n-z = 110 111 112 113 114 115 116 117 118 119 120 121 122

testcases k {lit rclass rstring} [lit-decode] {
    test marpa-slif-literal-decode-2.$k.1 "decode, string $lit" -body {
	marpa::slif::literal decode string $lit
    } -result [linsert $rstring 0 string]

    # %string is special, as it converts to primary codepoints.
    # Thus, no looping, but a separate test case.
    test marpa-slif-literal-decode-2.$k.2 "decode, %string $lit" -body {
	marpa::slif::literal decode %string $lit
    } -result [linsert [marpa unicode fold/c $rstring] 0 %string]

    testcases j type {
	charclass %charclass ^charclass ^%charclass
    } {
	test marpa-slif-literal-decode-3.$k.$j "decode, $type $lit" -body {
	    marpa::slif::literal decode $type $lit
	} -result [linsert $rclass 0 $type]
    }
}

# # ## ### ##### ######## ############# #####################
## decode-class - Generate internal rep for incoming character class

test marpa-slif-literal-decode-class-1.0 {decode-class, wrong args, not enough} -body {
    marpa::slif::literal decode-class
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

test marpa-slif-literal-decode-class-1.1 {decode-class, wrong args, too many} -body {
    marpa::slif::literal decode-class LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

testcases k {lit res __} [lit-decode] {
    test marpa-slif-literal-decode-class-2.$k "decode-class, $lit" -body {
	marpa::slif::literal decode-class $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode-string - Generate internal rep for incoming string
##                 ATTENTION: The `type` information is upvar'd from
##                 the calling scope, normally `decode`.

test marpa-slif-literal-decode-string-1.0 {decode-string, wrong args, not enough} -body {
    marpa::slif::literal decode-string
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

test marpa-slif-literal-decode-string-1.1 {decode-string, wrong args, too many} -body {
    marpa::slif::literal decode-string LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

testcases k {lit type res} {
    abcdef  string  {97 98 99 100 101 102}
    abcdef  %string {65 66 67 68 69 70}
} {
    test marpa-slif-literal-decode-string-2.$k "decode-string, $lit" -body {
	# `type` is upvar'd in.
	marpa::slif::literal decode-string $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## type - Determine type of incoming literal+nocase (string, charclass)

test marpa-slif-literal-type-1.0 {type, wrong args, not enough} -body {
    marpa::slif::literal type
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.1 {type, wrong args, not enough} -body {
    marpa::slif::literal type LITSTRING
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.2 {type, wrong args, too many} -body {
    marpa::slif::literal type LITSTRING NOCASE X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-2.0 {type, bogus} -body {
    marpa::slif::literal type {abcde} 0
} -returnCodes error -result {Unable to determine type of literal "abcde"}

testcases k {lit nocase res} {
    "'abcdef'"    0 {string abcdef}
    "\[abcdef\]"  0 {charclass abcdef}
    "\[^abcdef\]" 0 {^charclass abcdef}
    "'abcdef'"    1 {%string abcdef}
    "\[abcdef\]"  1 {%charclass abcdef}
    "\[^abcdef\]" 1 {^%charclass abcdef}
} {
    test marpa-slif-literal-type-2.$k "type, $lit" -body {
	marpa::slif::literal type $lit $nocase
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## unescape - Deal with Tcl \-escape in the literal, convert to regular characters.
## To handle
## - \[nrtfv\']-] (more ? ab...) CHECK Tcl docs
## - \xHHHHHHHHHH (hexes)
## - \OOO (octals)
## - \uHHHH (unicodes)

test marpa-slif-literal-unescape-1.0 {unescape, wrong args, not enough} -body {
    marpa::slif::literal unescape
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}

test marpa-slif-literal-unescape-1.1 {unescape, wrong args, too many} -body {
    marpa::slif::literal unescape LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}
  
testcases k {lit res} [lit-unescape] {
    test marpa-slif-literal-unescape-2.$k "unescape, $lit" -body {
	marpa::slif::literal unescape $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## tags - Strips tags from the literal. Currently only :i, :ic, both
##        indicating a case-insensitive literal

test marpa-slif-literal-tags-1.0 {tags, wrong args, not enough} -body {
    marpa::slif::literal tags
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

test marpa-slif-literal-tags-1.1 {tags, wrong args, too many} -body {
    marpa::slif::literal tags LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

testcases k {lit res} {
    foo:i  {foo 1}
    foo:ic {foo 1}
    foo:x  {foo:x 0}
    fox    {fox 0}
} {
    test marpa-slif-literal-tags-2.$k "tags, $lit" -body {
	marpa::slif::literal tags $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
cleanupTests
return
