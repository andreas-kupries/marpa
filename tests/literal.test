# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::slif::literal

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO

kt local   testing marpa

# # ## ### ##### ######## ############# #####################

kt source support/common.tcl
kt source support/dirs.tcl
kt source support/textutils.tcl

# # ## ### ##### ######## ############# #####################

proc F {defs} {
    join [lmap {sym lit} $defs { list $sym $lit }] \n
}

proc FE {str} {
    join [lmap line [split [string trim $str] \n] {
	string trim $line
    }] \n
}

proc RR {result rules literal} {
    set data [lassign $literal type]
    set dlit "($type ($data))"

    lappend map @@@ [marpa unicode max]
    lappend map @!  {STATE place done work <symbol>}
    lappend map @=  {STATE place done done <symbol>}
    lappend map @q  {STATE queue done <symbol>}
    lappend map @x  {STATE queue work <symbol>}
    lappend map RIL "Unable to reduce incomplete literal $dlit"
    lappend map RT  "Unable to reduce type $dlit"
    lappend map REL "Unable to reduce empty literal $dlit"

    # Resolve result fragment references
    while {[regexp {@result<([^>]*)>} $result -> path]} {
	set content [fget [redir $path]]
	set result [string map [list @result<${path}> $content] $result]
    }

    # Resolve standard, fixed shorthands, and strip indentation
    FE [string map $map $result]
}

# # ## ### ##### ######## ############# #####################
## [ok] symbol        \
## [ok] parse         / API (normalization)
## [ok] norm          \
## [ok] eltype        | Helpers. Exposed for testing internals
## [ok] ccunfold      | (before testing the visible API)
## [ok] ccsplit       |   |
## [ok] decode        \___/
## [ok] decode-string /
## [ok] decode-class  |
## [ok] type          |
## [ok] unescape      |
## [ok] tags
#
## [ok] r2container \
## [ok] reduce      / API (reduction)
## [ok] reduce1     \
## [ok] rstate       > Helpers. Exposed for testing the internals.
## [ok] ccranges    /

# # ## ### ##### ######## ############# #####################
## ccranges - Expand a mixed charclass into pure set of ranges

test marpa-slif-literal-ccranges-1.0 {ccranges, wrong args, not enough} -body {
    marpa::slif::literal ccranges
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccranges data"}

test marpa-slif-literal-ccranges-1.1 {ccranges, wrong args, too many} -body {
    marpa::slif::literal ccranges D X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccranges data"}

set k 0
foreach {data result} {
    10              10
    {{10 20}}       {{10 20}}
    braille         {{0x2800 0x28FF}}
    {10 braille}    {10 {0x2800 0x28FF}}
    {10245 braille} {{0x2800 0x28FF}}
} {
    incr k
    test marpa-slif-literal-ccranges-2.$k "ccranges, $data" -body {
	marpa::slif::literal ccranges $data
    } -result $result
}

# # ## ### ##### ######## ############# #####################
## r2container - Transfer a reduction result into a container

test marpa-slif-literal-r2container-1.0 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-1.1 {r2container, wrong args, not enough} -body {
    marpa::slif::literal r2container W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-1.2 {r2container, wrong args, too many} -body {
    marpa::slif::literal r2container W C X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal r2container reductions container"}

test marpa-slif-literal-r2container-2.0 {r2container, nothing} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {} $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result {}

test marpa-slif-literal-r2container-2.1 {r2container, all cases} -setup {
    set c [log GC] ; /trace GC
} -body {
    marpa::slif::literal r2container {{
	C {composite {A} {B}}
	S {composite {A B}}
	A {character 65}
	B {character 66}
    } {}} $c
    string trim [logged "\n"]
} -cleanup {
    unset c
} -result [norm-trace [trdir r2c21]]

# # ## ### ##### ######## ############# #####################
## reduce - reduction to minimum

test marpa-slif-literal-reduce-1.0 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.1 {reduce, wrong args, not enough} -body {
    marpa::slif::literal reduce W
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

test marpa-slif-literal-reduce-1.2 {reduce, wrong args, too many} -body {
    marpa::slif::literal reduce W R X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce worklist rules"}

set k 0
foreach {literal toexpect} {
    string {
	{} error RIL
    }
    {string 65 66 300} {
	{}     error RT
	K-STR  ok    {<symbol> {string 65 66 300}}
	D-STR1 error {Unable to reduce type (character (300))}
	{D-STR1 K-CHR} ok {
	    @CHR:<A> {character 65}
	    @CHR:<B> {character 66}
	    {@CHR:<\u012c>} {character 300}
	    <symbol> {composite {@CHR:<A> @CHR:<B> {@CHR:<\u012c>}}}
	}
	{D-STR1 D-CHR} ok {
	    @CHR:<A> {byte 65}
	    @CHR:<B> {byte 66}
	    {@BYTE:<\u00c4>} {byte 196}
	    {@BYTE:<\u00ac>} {byte 172}
	    {@CHR:<\u012c>} {composite {{@BYTE:<\u00c4>} {@BYTE:<\u00ac>}}}
	    <symbol> {composite {@CHR:<A> @CHR:<B> {@CHR:<\u012c>}}}
	}
	D-STR2 ok {
	    @BYTE:<A> {byte 65}
	    @BYTE:<B> {byte 66}
	    {@BYTE:<\u00c4>} {byte 196}
	    {@BYTE:<\u00ac>} {byte 172}
	    <symbol> {composite {@BYTE:<A> @BYTE:<B> {@BYTE:<\u00c4>} {@BYTE:<\u00ac>}}}
	}
    }
    {charclass 65 67} {
	{}     error RT
	K-CLS  ok    {<symbol> {charclass 65 67}}
	D-CLS1 error {Unable to reduce type (character (67))}
	{D-CLS1 K-CHR} ok {
	    @CHR:<A> {character 65}
	    @CHR:<C> {character 67}
	    <symbol> {composite @CHR:<A> @CHR:<C>}
	}
	{D-CLS1 D-CHR} ok {
	    @CHR:<A> {byte 65}
	    @CHR:<C> {byte 67}
	    <symbol> {composite @CHR:<A> @CHR:<C>}
	}
	D-CLS2 ok {
	    @BYTE:<A> {byte 65}
	    @BYTE:<C> {byte 67}
	    <symbol> {composite @BYTE:<A> @BYTE:<C>}
	}
    }
} {
    # Incrementally fill the above table with cases.  The basic flow
    # is covered by what we have now. Extending this is not about
    # coverage anymore, but about seeing the whole deconstruction for
    # all literal types and possible rule-sets.

    incr k
    set j 0
    foreach {rules code result} $toexpect {
	incr j

	test marpa-slif-literal-reduce-2.$k.$j "reduce $code ($literal) $rules, worklist" -body {
	    F [lindex [marpa::slif::literal reduce [list <symbol> $literal] $rules] 0]
	    # Access worklist, ignore the aliases, supposed to be empty
	} -returnCodes $code -result [RR $result $rules $literal]

	if {$code eq "error"} continue

	test marpa-slif-literal-reduce-3.$k.$j "reduce $code ($literal) $rules, aliases" -body {
	    lindex [marpa::slif::literal reduce [list <symbol> $literal] $rules] 1
	    # Access aliases, always empty
	} -result {}
}
}

# # ## ### ##### ######## ############# #####################
## reduce1 - single reduction step

test marpa-slif-literal-reduce1-1.0 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.1 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.2 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.3 {reduce1, wrong args, not enough} -body {
    marpa::slif::literal reduce1 S L R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

test marpa-slif-literal-reduce1-1.4 {reduce1, wrong args, too many} -body {
    marpa::slif::literal reduce1 S L R S X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal reduce1 litsymbol literal rules state"}

set k 0
foreach {literal toexpect} {
    string {
	{}     error RIL
	K-STR  error RIL
	D-STR1 error RIL
	D-STR2 error RIL
    }
    {string 65 66 300} {
	{}     error RT
	K-STR  ok    {@q {string 65 66 300}}
	D-STR1 ok    {@! {composite {{character 65} {character 66} {character 300}}}}
	D-STR2 ok    {@! {composite {{byte 65} {byte 66} {byte 196} {byte 172}}}}
    }
    %string {
	{}     error RIL
	K-%STR error RIL
	D-%STR error RIL
    }
    {%string 97 98} {
	{}     error  RT
	K-%STR ok     {@q {%string 97 98}}
	D-%STR ok     {@! {composite {{%character 97} {%character 98}}}}
	!----- ------ { -- reduce1 ^^ does not normalize, rstate place does -- }
    }
    character {
	{}    error RIL
	K-CHR error RIL
	D-CHR error RIL
    }
    {character 65} {
	{}    error RT
	K-CHR ok    {@q {character 65}}
	D-CHR ok    {@q {byte 65}}
    }
    {character 300} {
	{}    error RT
	K-CHR ok    {@q {character 300}}
	D-CHR ok    {@! {composite {{byte 196} {byte 172}}}}
	!---- ----- {                     ^110.00100 ^10.101100   }
	!---- ----- {                     = 0b'00100  0b'101100   }
	!---- ----- {                     = 0b'00100 101100 = 300 }
    }
    charclass {
	{}     error RIL
	K-CLS  error RIL
	D-CLS1 error RIL
	D-CLS2 error RIL
	D-CLS3 error RIL
    }
    {charclass {10 20} 300} {
	{}     error RT
	K-CLS  ok    {@q {charclass {10 20} 300}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{character 300}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 196} {byte 172}}}}
	D-CLS3 ok    {@q {charclass {10 20} 300}}
    }
    {charclass {10 20} braille} {
	{}     error RT
	K-CLS  ok    {@q {charclass {10 20} braille}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass {10 20} {0x2800 0x28FF}}}
    }
    {charclass 300 braille} {
	{}     error RT
	K-CLS  ok    {@q {charclass 300 braille}}
	D-CLS1 ok    {@! {composite {{character 300}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{byte 196} {byte 172}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass 300 {0x2800 0x28FF}}}
    }
    {charclass 300 print} {
	{}     error RT
	K-CLS  ok    {@q {charclass 300 print}}
	D-CLS1 ok    {@! {composite {{character 300}} {{named-class print}}}}
	!----- --    { D-CLS2 skipped, avoid large ASBR }
	D-CLS3 ok    {@q {charclass 300 print}}
    }
    {charclass {10 20} 300 braille} {
	{}     error RT
	K-CLS  ok    {@q {charclass {10 20} 300 braille}}
	D-CLS1 ok    {@! {composite {{range 10 20}} {{character 300}} {{named-class braille}}}}
	D-CLS2 ok    {@! {composite {{brange 10 20}} {{byte 196} {byte 172}} {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-CLS3 ok    {@q {charclass {10 20} 300 {0x2800 0x28FF}}}
    }
    ^charclass {
	{}      error RIL
	K-^CLS  error RIL
	D-^CLS1 error RIL
	D-^CLS2 error RIL
    }
    {^charclass {10 20} 300} {
	{}      error RT
	K-^CLS  ok    {@q {^charclass {10 20} 300}}
	D-^CLS1 ok    {@x {charclass {0 9} {21 299} {301 @@@}}}
	D-^CLS2 ok    {@q {^charclass {10 20} 300}}
    }
    {^charclass {10 20} braille} {
	{}      error RT
	K-^CLS  ok    {@q {^charclass {10 20} braille}}
	D-^CLS1 ok    {@x {charclass {0 9} {21 10239} {10496 @@@}}}
	D-^CLS2 ok    {@q {^charclass {10 20} {0x2800 0x28FF}}}
    }
    {^charclass 300 braille} {
	{}      error RT
	K-^CLS  ok    {@q {^charclass 300 braille}}
	D-^CLS1 ok    {@x {charclass {0 299} {301 10239} {10496 @@@}}}
	D-^CLS2 ok    {@q {^charclass 300 {0x2800 0x28FF}}}
    }
    {^charclass {10 20} 300 braille} {
	{}      error RT
	K-^CLS  ok    {@q {^charclass {10 20} 300 braille}}
	D-^CLS1 ok    {@x {charclass {0 9} {21 299} {301 10239} {10496 @@@}}}
	D-^CLS2 ok    {@q {^charclass {10 20} 300 {0x2800 0x28FF}}}
    }
    {^charclass 20 punct} {
	D-^CLS2 ok {@q {^charclass 20 punct}}
    }
    named-class {
	{}     error RIL
	K-NCC  error RIL
	D-NCC1 error RIL
	D-NCC2 error RIL
	D-NCC3 error RIL
	D-NCC4 error RIL
    }
    {named-class braille} {
	{}     error RT
	K-NCC  ok    {@q {named-class braille}}
	D-NCC1 ok    {@x {charclass {0x2800 0x28FF}}}
	D-NCC2 ok    {@! {composite {{byte 226} {brange 160 163} {brange 128 191}}}}
	D-NCC3 ok    {@x {charclass {0x2800 0x28FF}}}
	D-NCC4 ok    {
	    @= {composite {{symbol <symbol>:A0}}}
	    @=:A0 {composite {{byte 226} {brange 160 163} {brange 128 191}}}
	}
    }
    {named-class punct} {
	D-NCC3 ok    {@q {named-class punct}}
    }
    %named-class {
	{}      error RIL
	K-%NCC  error RIL
	D-%NCC1 error RIL
	D-%NCC2 error RIL
    }
    {%named-class braille} {
	{}      error RT
	K-%NCC  ok    {@q {%named-class braille}}
	D-%NCC1 ok    {@x {charclass {10240 10495}}}
	D-%NCC2 ok    {@! {composite {{byte 226} {brange 160 163} {brange 128 191}}}}
    }
    {%named-class lu} {
	{}      error RT
	K-%NCC  ok    {@q {%named-class lu}}
	D-%NCC1 ok    {@x {@result<lu.nocase.ncc1>}}
	D-%NCC2 ok    {@! {@result<lu.nocase.ncc2>}}
    }
    ^named-class {
	{}      error RIL
	K-^NCC  error RIL
	D-^NCC1 error RIL
	D-^NCC2 error RIL
    }
    {^named-class braille} {
	{}      error RT
	K-^NCC  ok    {@q {^named-class braille}}
	D-^NCC1 ok    {@x {charclass {0 10239} {10496 @@@}}}
	D-^NCC2 ok    {@x {charclass {0 10239} {10496 @@@}}}
    }
    {^named-class punct} {
	D-^NCC2 ok    {@q {^named-class punct}}
    }
    ^%named-class {
	{}       error RIL
	K-^%NCC  error RIL
	D-^%NCC1 error RIL
	D-^%NCC2 error RIL
    }
    {^%named-class braille} {
	{}       error RT
	K-^%NCC  ok    {@q {^%named-class braille}}
	D-^%NCC1 ok    {@x {charclass {0 10239} {10496 @@@}}}
	D-^%NCC2 ok    {@! {@result<braille.neg.nocase.ncc2>}}
    }
    {^%named-class lu} {
	{}       error RT
	K-^%NCC  ok    {@q {^%named-class lu}}
	D-^%NCC1 ok    {@x {@result<lu.neg.nocase.ncc1>}}
	D-^%NCC2 ok    {@! {@result<lu.neg.nocase.ncc2>}}
    }
    range {
	{}     error RIL
	K-RAN  error RIL
	D-RAN1 error RIL
	D-RAN2 error RIL
    }
    {range 20 10} {
	{}     error REL
	K-RAN  error REL
	D-RAN1 error REL
	D-RAN2 error REL
    }
    {range 10 10} {
	{}     error REL
	K-RAN  error REL
	D-RAN1 error REL
	D-RAN2 error REL
    }
    {range 10 11} {
	{}     error RT
	K-RAN  ok    {@q {range 10 11}}
	D-RAN1 ok    {@! {composite {{character 10}} {{character 11}}}}
	D-RAN2 ok    {@q {brange 10 11}}
    }
    %range {
	{}     error RIL
	K-%RAN error RIL
	D-%RAN error RIL
    }
    {%range 20 10} {
	{}     error REL
	K-%RAN error REL
	D-%RAN error REL
    }
    {%range 10 10} {
	{}     error REL
	K-%RAN error REL
	D-%RAN error REL
    }
    {%range 97 99} {
	{}     error RT
	K-%RAN ok    {@q {%range 97 99}}
	D-%RAN ok    {@x {charclass {65 67} {97 99}}}
    }
    ^range {
	{}      error RIL
	K-^RAN  error RIL
	D-^RAN1 error RIL
	D-^RAN2 error RIL
    }
    {^range 0 @@@} {
	{}      error REL
	K-^RAN  error REL
	D-^RAN1 error REL
	D-^RAN2 error REL
    }
    {^range 0 10} {
	{}      error RT
	K-^RAN  ok    {@q {^range 0 10}}
	D-^RAN1 ok    {@x {range 11 @@@}}
	D-^RAN2 ok    {@! {@result<range.0-10.neg.ran2>}}
    }
    {^range 20 @@@} {
	{}      error RT
	K-^RAN  ok    {@q {^range 20 @@@}}
	D-^RAN1 ok    {@x {range 0 19}}
	D-^RAN2 ok    {@q {brange 0 19}}
    }
    {^range 10 20} {
	{}      error RT
	K-^RAN  ok    {@q {^range 10 20}}
	D-^RAN1 ok    {@x {charclass {0 9} {21 @@@}}}
	D-^RAN2 ok    {@! {@result<range.10-20.neg.ran2>}}
    }
    ^character {
	{}     error RIL
	K-^CHR error RIL
	D-^CHR error RIL
    }
    {^character 300} {
	{}     error RT
	K-^CHR ok    {@q {^character 300}}
	D-^CHR ok    {@x {charclass {0 299} {301 @@@}}}
	!----- ----- { using 2 ranges,    -^- 300 excluded }
    }
} {
    # Skip annotations
    if {[string match !* $literal]} { puts XXX.reduce1.$literal ; continue }

    # Fix placeholder for semi-dynamic upper unicode limit
    set literal [string map [list @@@ [marpa unicode max]] $literal]

    incr k
    set j 0
    foreach {rules code result} $toexpect {
	# Skip annotations
	if {[string match !* $rules]} continue ;#{ puts XXX.reduce1.$literal.$rules ; continue }
	if {[string match X* $rules]} { puts XXX.reduce1.$literal.$rules ; continue }

	incr j
	test marpa-slif-literal-reduce1-2.$k.$j "reduce1 $code ($literal) $rules" -setup {
	    set state [log STATE] ; /trace STATE
	} -body {
	    marpa::slif::literal reduce1 <symbol> $literal $rules $state
	    string trim [logged "\n"]
	} -cleanup {
	    catch { logged }
	    unset state
	} -returnCodes $code -result [RR $result $rules $literal]
    }
}

# # ## ### ##### ######## ############# #####################
## rstate - state object for reducer
## [ok] new, create
## [ok] work?
## [ok] take
## [ok] place
## [ok] queue
## [ok] symbolize
## [ok] results

# # ## ### ##### ######## ############# #####################
## rstate constructor

test marpa-slif-literal-rstate-cons-1.0 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate new
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.1 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate new W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new worklist"}

test marpa-slif-literal-rstate-cons-1.2 {rstate, cons, wrong args, not enough} -body {
    marpa::slif::literal rstate create R
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-1.3 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate create R W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R worklist"}

test marpa-slif-literal-rstate-cons-2.0 {rstate, cons, auto} -body {
    set r [marpa::slif::literal rstate new {}]
} -cleanup {
    $r destroy
    unset r
} -match glob -result ::oo::Obj*

test marpa-slif-literal-rstate-cons-2.1 {rstate, cons, explicitly named} -body {
    marpa::slif::literal rstate create R {}
} -cleanup {
    R destroy
} -result ::R

# # ## ### ##### ######## ############# #####################
## rstate work?

test marpa-slif-literal-rstate-work?-1.0 {rstate, work?, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work? X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R work?"}

test marpa-slif-literal-rstate-work?-2.0 {rstate, work?, none} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R work?
} -cleanup {
    R destroy
} -result 0

test marpa-slif-literal-rstate-work?-2.1 {rstate, work?, some} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
} -body {
    R work?
} -cleanup {
    R destroy
} -result 2

# # ## ### ##### ######## ############# #####################
## rstate take

test marpa-slif-literal-rstate-take-1.0 {rstate, take, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R take"}

test marpa-slif-literal-rstate-take-2.0 {rstate, take, nothing} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R take
} -cleanup {
    R destroy
} -returnCodes error -result {No work available}

test marpa-slif-literal-rstate-take-2.1 {rstate, take, last (stack)} -setup {
    marpa::slif::literal rstate create R {
	B {string 65 66 67}
	A {character 78}
    }
} -body {
    R take
} -cleanup {
    R destroy
} -result {A {character 78}}

# # ## ### ##### ######## ############# #####################
## rstate place

test marpa-slif-literal-rstate-place-1.0 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.1 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.2 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.3 {rstate, place, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.4 {rstate, place, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place Q SQ S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-2.0.0 {rstate, place (literal), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.0.1 {rstate, place (literal), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done --- S {character 45}
    R results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-place-2.1.0 {rstate, place (literal), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.1.1 {rstate, place (literal), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place work --- S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-place-2.2.0 {rstate, place (composite), results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.2.1 {rstate, place (composite), results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done done S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results]
} -cleanup {
    R destroy
} -result {0 --- {{S {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}} {}}}

test marpa-slif-literal-rstate-place-2.3.0 {rstate, place (composite), work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.3.1 {rstate, place (composite), work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R place done work S {composite {{character 45}} {{character 46}}}
    list [R work?] --- [R results] --- [R take] --- [R take]
} -cleanup {
    R destroy
} -result {2 --- {{S {composite @CHR:<-> @CHR:<.>}} {}} --- {@CHR:<.> {character 46}} --- {@CHR:<-> {character 45}}}

# # ## ### ##### ######## ############# #####################
## rstate queue

test marpa-slif-literal-rstate-queue-1.0 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.1 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.2 {rstate, queue, wrong args, not enough} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.3 {rstate, queue, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue Q S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-2.0.0 {rstate, queue, results} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.0.1 {rstate, queue, results, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue done S {character 45}
    R results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-queue-2.1.0 {rstate, queue, work} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.1.1 {rstate, queue, work, state} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R queue work S {character 45}
    R take
} -cleanup {
    R destroy
} -result {S {character 45}}

# # ## ### ##### ######## ############# #####################
## rstate results

test marpa-slif-literal-rstate-results-1.0 {rstate, results, wrong args, too many} -setup {
    marpa::slif::literal rstate create R {}
} -body {
    R results X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R results"}

test marpa-slif-literal-rstate-results-2.0 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # Empty results. Because this is all in the work-queue.
} -body {
    R results
} -cleanup {
    R destroy
} -result {{} {}}

test marpa-slif-literal-rstate-results-2.1 {rstate, results} -setup {
    marpa::slif::literal rstate create R {
	A {character 12}
	B {string 65 66 67}
    }
    # Shift the initial work queue over into results, unchanged.
    R queue done {*}[R take]
    R queue done {*}[R take]
} -body {
    R results
} -cleanup {
    R destroy
} -result {{A {character 12} B {string 65 66 67}} {}}

# # ## ### ##### ######## ############# #####################
## symbol - Generate a symbol for a literal from its representation.

test marpa-slif-literal-symbol-1.0 {symbol, wrong args, not enough} -body {
    marpa::slif::literal symbol
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

test marpa-slif-literal-symbol-1.1 {symbol, wrong args, too many} -body {
    marpa::slif::literal symbol LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal symbol literal"}

set k 0
foreach {literal symbol} {
    {%named-class braille}                        @%NCC:<[:braille:]>
    {%string 65 45}                               @%STR:<A->
    {^%named-class braille}                       @^%NCC:<[:braille:]>
    {^character 45}                               @^CHR:<->
    {^character 97}                               @^CHR:<a>
    {^charclass 45 %braille}                      @^CLS:<-[:%braille:]>
    {^charclass 45 {65 70} {97 102} %braille}     @^CLS:<-A-Fa-f[:%braille:]>
    {^charclass 45 {65 70} {97 102}}              @^CLS:<-A-Fa-f>
    {^charclass 45 {97 102} braille}              @^CLS:<-a-f[:braille:]>
    {^charclass 45 {97 102}}                      @^CLS:<-a-f>
    {^charclass 65 97 %braille}                   @^CLS:<Aa[:%braille:]>
    {^charclass 65 97}                            @^CLS:<Aa>
    {^charclass 97 braille}                       @^CLS:<a[:braille:]>
    {^charclass {45 47} %braille}                 @^CLS:<--/[:%braille:]>
    {^charclass {45 47} 65 97}                    @^CLS:<--/Aa>
    {^charclass {65 70} {97 102} %braille}        @^CLS:<A-Fa-f[:%braille:]>
    {^charclass {65 70} {97 102}}                 @^CLS:<A-Fa-f>
    {^charclass {97 102} braille}                 @^CLS:<a-f[:braille:]>
    {^named-class braille}                        @^NCC:<[:braille:]>
    {^range 97 102}                               @^RAN:<af>
    {character 45}                                @CHR:<->
    {character 97}                                @CHR:<a>
    {charclass 45 %braille}                       @CLS:<-[:%braille:]>
    {charclass 45 {65 70} {97 102} %braille}      @CLS:<-A-Fa-f[:%braille:]>
    {charclass 45 {65 70} {97 102}}               @CLS:<-A-Fa-f>
    {charclass 45 {97 102} braille}               @CLS:<-a-f[:braille:]>
    {charclass 45 {97 102}}                       @CLS:<-a-f>
    {charclass 65 97 %braille}                    @CLS:<Aa[:%braille:]>
    {charclass 65 97}                             @CLS:<Aa>
    {charclass 97 braille}                        @CLS:<a[:braille:]>
    {charclass {45 47} %braille}                  @CLS:<--/[:%braille:]>
    {charclass {45 47} 65 97}                     @CLS:<--/Aa>
    {charclass {65 70} {97 102} %braille}         @CLS:<A-Fa-f[:%braille:]>
    {charclass {65 70} {97 102}}                  @CLS:<A-Fa-f>
    {charclass {97 102} braille}                  @CLS:<a-f[:braille:]>
    {named-class braille}                         @NCC:<[:braille:]>
    {range 97 102}                                @RAN:<af>
    {string 97 45}                                @STR:<a->
} {
    incr k
    test marpa-slif-literal-symbol-2.$k "symbol, $literal" -body {
	marpa::slif::literal symbol $literal
    } -result $symbol
}

# # ## ### ##### ######## ############# #####################
## parse - Parse a literal string into a normalized internal representation.

test marpa-slif-literal-parse-1.0 {parse, wrong args, not enough} -body {
    marpa::slif::literal parse
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

test marpa-slif-literal-parse-1.2 {parse, wrong args, too many} -body {
    marpa::slif::literal parse LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal parse litstring"}

set k 0
foreach {rule litstring res} {
    N01 {'a'}                        {character 97}
    N02 {'a-'}                       {string 97 45}

    N03 {'a':i}                      {charclass 65 97}
    N03 {'-':i}                      {character 45}
    N04 {'a-':i}                     {%string 65 45}

    N05 {[a]}                        {character 97}
    N06 {[a-f]}                      {range 97 102}
    N07 {[[:braille:]]}              {named-class braille}
    N08 {[[:braille:]a]}             {charclass 97 braille}
    N08 {[\-a-f]}                    {charclass 45 {97 102}}
    N08 {[a-f[:braille:]]}           {charclass {97 102} braille}
    N08 {[a-f[:braille:]\-]}         {charclass 45 {97 102} braille}

    N09 {[a]:i}                      {charclass 65 97}
    N09 {[\-]:i}                     {character 45}
    N10 {[a-f]:i}                    {charclass {65 70} {97 102}}
    N11 {[[:braille:]]:i}            {%named-class braille}
    N12 {[a[:braille:]]:i}           {charclass 65 97 %braille}
    N12 {[[:braille:]\-]:i}          {charclass 45 %braille}
    N12 {[a-f\-]:i}                  {charclass 45 {65 70} {97 102}}
    N12 {[\x2D-/a]:i}                {charclass {45 47} 65 97}
    N12 {[[:braille:]a-f]:i}         {charclass {65 70} {97 102} %braille}
    N12 {[\055-/[:braille:]]:i}      {charclass {45 47} %braille}
    N12 {[\055[:braille:]a-f]:i}     {charclass 45 {65 70} {97 102} %braille}

    N13 {[^a]}                       {^character 97}
    N14 {[^abcdef]}                  {^range 97 102}
    N15 {[^[:braille:]]}             {^named-class braille}
    N16 {[^[:braille:]a]}            {^charclass 97 braille}
    N16 {[^a-c\055d-f]}              {^charclass 45 {97 102}}
    N16 {[^d-f[:braille:]a-e]}       {^charclass {97 102} braille}
    N16 {[^a-c\055[:braille:]b-f]}  {^charclass 45 {97 102} braille}

    N17 {[^a]:i}                     {^charclass 65 97}
    N17 {[^\x2d]:i}                  {^character 45}
    N18 {[^a-f]:i}                   {^charclass {65 70} {97 102}}
    N19 {[^[:braille:]]:i}           {^%named-class braille}
    N20 {[^[:braille:]a]:i}          {^charclass 65 97 %braille}
    N20 {[^[:braille:]\055]:i}       {^charclass 45 %braille}
    N20 {[^a-c\055b-f]:i}            {^charclass 45 {65 70} {97 102}}
    N20 {[^\055\056\057a]:i}         {^charclass {45 47} 65 97}
    N20 {[^[:braille:]a-f]:i}        {^charclass {65 70} {97 102} %braille}
    N20 {[^[:braille:]\--/]:i}       {^charclass {45 47} %braille}
    N20 {[^\055abcdef[:braille:]]:i} {^charclass 45 {65 70} {97 102} %braille}
} {
    incr k
    test marpa-slif-literal-parse-2.$k "parse, $rule, $litstring" -body {
	marpa::slif::literal parse $litstring
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## norm - Normalize literal without deconstructing it into multiple pieces.
##        Keeps named classes, ranges

test marpa-slif-literal-norm-1.0 {norm, wrong args, not enough} -body {
    marpa::slif::literal norm
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

test marpa-slif-literal-norm-1.2 {norm, wrong args, too many} -body {
    marpa::slif::literal norm LITERAL X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal norm literal"}

set k 0
foreach {rule literal res} {
    N01 {string 97}             {character 97}
    N02 {string 97 45}          --

    N03 {%string 97}            {charclass 65 97}
    N03 {%string 45}            {character 45}
    N04 {%string 65 45}         --

    N05 {charclass 97}                    {character 97}
    N06 {charclass {97 102}}              {range 97 102}
    N07 {charclass braille}               {named-class braille}
    N08 {charclass 97 braille}            --mix:char,named
    N08 {charclass 45 {97 102}}           --mix:char,range
    N08 {charclass {97 102} braille}      --mix:range,named
    N08 {charclass 45 {97 102} braille}   --mix:char,range,named

    N09 {%charclass 97}                   {charclass 65 97}
    N09 {%charclass 45}                   {character 45}
    N10 {%charclass {97 102}}             {charclass {65 70} {97 102}}
    N11 {%charclass braille}              {%named-class braille}
    N12 {%charclass 97 braille}           {charclass 65 97 %braille}
    N12 {%charclass 45 braille}           {charclass 45 %braille}
    N12 {%charclass 45 {97 102}}          {charclass 45 {65 70} {97 102}}
    N12 {%charclass {45 47} 97}           {charclass {45 47} 65 97}
    N12 {%charclass {97 102} braille}     {charclass {65 70} {97 102} %braille}
    N12 {%charclass {45 47} braille}      {charclass {45 47} %braille}
    N12 {%charclass 45 {97 102} braille}  {charclass 45 {65 70} {97 102} %braille}

    N13 {^charclass 97}                   {^character 97}
    N14 {^charclass {97 102}}             {^range 97 102}
    N15 {^charclass braille}              {^named-class braille}
    N16 {^charclass 97 braille}           --mix:char,named
    N16 {^charclass 45 {97 102}}          --mix:char,range
    N16 {^charclass {97 102} braille}     --mix:range,named
    N16 {^charclass 45 {97 102} braille}  --mix:char,range,named

    N17 {^%charclass 97}                  {^charclass 65 97}
    N17 {^%charclass 45}                  {^character 45}
    N18 {^%charclass {97 102}}            {^charclass {65 70} {97 102}}
    N19 {^%charclass braille}             {^%named-class braille}
    N20 {^%charclass 97 braille}          {^charclass 65 97 %braille}
    N20 {^%charclass 45 braille}          {^charclass 45 %braille}
    N20 {^%charclass 45 {97 102}}         {^charclass 45 {65 70} {97 102}}
    N20 {^%charclass {45 47} 97}          {^charclass {45 47} 65 97}
    N20 {^%charclass {97 102} braille}    {^charclass {65 70} {97 102} %braille}
    N20 {^%charclass {45 47} braille}     {^charclass {45 47} %braille}
    N20 {^%charclass 45 {97 102} braille} {^charclass 45 {65 70} {97 102} %braille}
} {
    incr k
    if {[string match --* $res]} { set res $literal }
    test marpa-slif-literal-norm-2.$k "norm, $rule, $literal" -body {
	marpa::slif::literal norm $literal
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## eltype - Determine type of charclass element

test marpa-slif-literal-eltype-1.0 {eltype, wrong args, not enough} -body {
    marpa::slif::literal eltype
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

test marpa-slif-literal-eltype-1.2 {eltype, wrong args, too many} -body {
    marpa::slif::literal eltype CCELEMENT X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal eltype ccelement"}

set k 0
foreach {ccelement res} {
    37      character
    {48 57} range
    alnum   named-class
} {
    incr k
    test marpa-slif-literal-eltype-2.$k "eltype, $ccelement" -body {
	marpa::slif::literal eltype $ccelement
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccunfold - Case-expand a charclass to contain original and case-equivalent characters.

test marpa-slif-literal-ccunfold-1.0 {ccunfold, wrong args, not enough} -body {
    marpa::slif::literal ccunfold
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

test marpa-slif-literal-ccunfold-1.2 {ccunfold, wrong args, too many} -body {
    marpa::slif::literal ccunfold DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccunfold data"}

set k 0
foreach {data res} {
    {37 {48 57} {97 122} alnum braille}
    {37 {48 57} {65 90} {97 122} {304 305} 383 8490 %alnum %braille}
} {
    incr k
    test marpa-slif-literal-ccunfold-2.$k "ccunfold, $data" -body {
	marpa::slif::literal ccunfold $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## ccsplit - Split char class data into codes/ranges vs named

test marpa-slif-literal-ccsplit-1.0 {ccsplit, wrong args, not enough} -body {
    marpa::slif::literal ccsplit
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

test marpa-slif-literal-ccsplit-1.2 {ccsplit, wrong args, too many} -body {
    marpa::slif::literal ccsplit DATA X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal ccsplit data"}

set k 0
foreach {data res} {
    {37 {48 57} {97 122} alnum braille}    {{37 {48 57} {97 122}} {alnum braille}}
} {
    incr k
    test marpa-slif-literal-ccsplit-2.$k "ccsplit, $data" -body {
	marpa::slif::literal ccsplit $data
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode - Generate internal rep for incoming typed literal

test marpa-slif-literal-decode-1.0 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.1 {decode, wrong args, not enough} -body {
    marpa::slif::literal decode TYPE
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-1.2 {decode, wrong args, too many} -body {
    marpa::slif::literal decode TYPE LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode type litstring"}

test marpa-slif-literal-decode-2.0 {decode, bogus type} -body {
    marpa::slif::literal decode bogus abcdef
} -returnCodes error -result {Unable to decode bogus type "bogus"}

#       a   b   c   d   e   f   g   h   i   j   k   l   m
# a-m = 97  98  99  100 101 102 103 104 105 106 107 108 109
#       n   o   p   q   r   s   t   u   v   w   x   y   z
# n-z = 110 111 112 113 114 115 116 117 118 119 120 121 122

set k 0
foreach {lit rclass rstring} {
    abcdef                 {{97 102}}            {97 98 99 100 101 102}
    a-z                    {{97 122}}            {97 45 122}
    {[:braille:]}          {braille}             {91 58 98 114 97 105 108 108 101 58 93}
    --z                    {{45 122}}            {45 45 122}
    %--                    {{37 45}}             {37 45 45}
    a-z0-9%                {37 {48 57} {97 122}} {97 45 122 48 45 57 37}
    {0-9[:alnum:]}         {{48 57} alnum}       {48 45 57 91 58 97 108 110 117 109 58 93}
    {[:braille:][:alnum:]} {alnum braille}       {91 58 98 114 97 105 108 108 101 58 93 91 58 97 108 110 117 109 58 93}
} {
    incr k

    test marpa-slif-literal-decode-2.$k.1 "decode, string $lit" -body {
	marpa::slif::literal decode string $lit
    } -result [linsert $rstring 0 string]

    # %string is special, as it converts to primary codepoints.
    # Thus, no looping, but a separate test case.
    test marpa-slif-literal-decode-2.$k.2 "decode, %string $lit" -body {
	marpa::slif::literal decode %string $lit
    } -result [linsert [marpa unicode fold/c $rstring] 0 %string]

    set j 0
    foreach type {
	charclass %charclass ^charclass ^%charclass
    } {
	incr j
	test marpa-slif-literal-decode-3.$k.$j "decode, $type $lit" -body {
	    marpa::slif::literal decode $type $lit
	} -result [linsert $rclass 0 $type]
    }
}

# # ## ### ##### ######## ############# #####################
## decode-class - Generate internal rep for incoming character class

test marpa-slif-literal-decode-class-1.0 {decode-class, wrong args, not enough} -body {
    marpa::slif::literal decode-class
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

test marpa-slif-literal-decode-class-1.1 {decode-class, wrong args, too many} -body {
    marpa::slif::literal decode-class LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-class litstring"}

set k 0
foreach {lit res} {
    abcdef                 {{97 102}}
    a-z                    {{97 122}}
    {[:braille:]}          {braille}
    --z                    {{45 122}}
    %--                    {{37 45}}
    a-z0-9%                {37 {48 57} {97 122}}
    {0-9[:alnum:]}         {{48 57} alnum}
    {[:braille:][:alnum:]} {alnum braille}
} {
    incr k
    test marpa-slif-literal-decode-class-2.$k "decode-class, $lit" -body {
	marpa::slif::literal decode-class $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## decode-string - Generate internal rep for incoming string
##                 ATTENTION: The `type` information is upvar'd from
##                 the calling scope, normally `decode`.

test marpa-slif-literal-decode-string-1.0 {decode-string, wrong args, not enough} -body {
    marpa::slif::literal decode-string
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

test marpa-slif-literal-decode-string-1.1 {decode-string, wrong args, too many} -body {
    marpa::slif::literal decode-string LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal decode-string litstring"}

set k 0
foreach {lit type res} {
    abcdef  string  {97 98 99 100 101 102}
    abcdef  %string {65 66 67 68 69 70}
} {
    incr k
    test marpa-slif-literal-decode-string-2.$k "decode-string, $lit" -body {
	# `type` is upvar'd in.
	marpa::slif::literal decode-string $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## type - Determine type of incoming literal+nocase (string, charclass)

test marpa-slif-literal-type-1.0 {type, wrong args, not enough} -body {
    marpa::slif::literal type
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.1 {type, wrong args, not enough} -body {
    marpa::slif::literal type LITSTRING
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-1.2 {type, wrong args, too many} -body {
    marpa::slif::literal type LITSTRING NOCASE X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal type litstring nocase"}

test marpa-slif-literal-type-2.0 {type, bogus} -body {
    marpa::slif::literal type {abcde} 0
} -returnCodes error -result {Unable to determine type of literal "abcde"}

set k 0
foreach {lit nocase res} {
    "'abcdef'"    0 {string abcdef}
    "\[abcdef\]"  0 {charclass abcdef}
    "\[^abcdef\]" 0 {^charclass abcdef}
    "'abcdef'"    1 {%string abcdef}
    "\[abcdef\]"  1 {%charclass abcdef}
    "\[^abcdef\]" 1 {^%charclass abcdef}
} {
    incr k
    test marpa-slif-literal-type-2.$k "type, $lit" -body {
	marpa::slif::literal type $lit $nocase
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## unescape - Deal with Tcl \-escape in the literal, convert to regular characters.
## To handle
## - \[nrtfv\']-] (more ? ab...) CHECK Tcl docs
## - \xHHHHHHHHHH (hexes)
## - \OOO (octals)
## - \uHHHH (unicodes)

test marpa-slif-literal-unescape-1.0 {unescape, wrong args, not enough} -body {
    marpa::slif::literal unescape
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}

test marpa-slif-literal-unescape-1.1 {unescape, wrong args, too many} -body {
    marpa::slif::literal unescape LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal unescape litstring"}

set k 0
foreach {lit res} {
    "\\n\\r\\t\\f\\v\\a\\'\\\]\\-\\\\"  "\n\r\t\f\v\a'\]-\\"
    "\\377"                             "\377"
    "\xFFFFFFFFFFFF"                    "\xFF"
    "\\u2202"                           "\u2202"
    "abcdef"                            "abcdef"
} {
    incr k
    test marpa-slif-literal-unescape-2.$k "unescape, $lit" -body {
	marpa::slif::literal unescape $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
## tags - Strips tags from the literal. Currently only :i, :ic, both
##        indicating a case-insensitive literal

test marpa-slif-literal-tags-1.0 {tags, wrong args, not enough} -body {
    marpa::slif::literal tags
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

test marpa-slif-literal-tags-1.1 {tags, wrong args, too many} -body {
    marpa::slif::literal tags LITSTRING X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal tags litstring"}

set k 0
foreach {lit res} {
    foo:i  {foo 1}
    foo:ic {foo 1}
    foo:x  {foo:x 0}
    fox    {fox 0}
} {
    incr k
    test marpa-slif-literal-tags-2.$k "tags, $lit" -body {
	marpa::slif::literal tags $lit
    } -result $res
}

# # ## ### ##### ######## ############# #####################
rename F {}
rename FE {}
cleanupTests
return
