# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2017-present Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::slif::literal
## State class for reductions (literals to process, work and result queues)

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO

kt local   testing marpa::slif::literal::redux

# # ## ### ##### ######## ############# #####################

kt source support/common.tcl
kt source support/literals.tcl

proc setup {{w {}}} {
    marpa::slif::literal rstate create R
    if {[llength $w]} { R work-on $w }
    # Access to internal methods, for testing.
    oo::objdefine R {
	export Active
	export ClearActive
	export Place
	export Queue
	export Results
	export Symbolize
	export Take
	export Undecided
	export Work?
	export ForSymbol
    }
    # Declare symbol callback outside of reduction. Test support.
    R ForSymbol ::SYM
    return R
}

proc SYM {s l} { marpa::slif::literal::util::symbol $l }

proc setup_foo {} {
    namespace eval ::foo {
	namespace export reduce symbol
	namespace ensemble create
    }
    proc ::foo::symbol {state literal} {
	marpa::slif::literal::util::symbol $literal
    }
    proc ::foo::reduce {type r args} {
	#puts XXX\t<<[info level 0]>>
	switch -exact -- $type {
	    charclass {
		# For this test we know that the CC details are codepoints
		$r rules [lmap c $args {
		    # each alternate is a sequence of a single character literal
		    list [list character $c]
		}]
	    }
	    character {
		$r keep
	    }
	}
	error X|$type
    }
    return
}

proc clear_foo {} {
    namespace delete ::foo
}

# Helper to swallow a `return -code return` generated by the DSL commands.
proc RX {args} {
    R {*}$args
}

# # ## ### ##### ######## ############# #####################
## redux - Main API to reduction

# # ## ### ##### ######## ############# #####################
## rstate - state object for reducer, including main loop and DSL API.
## [ok] new, create
## [ok] reduce
## [..] process		TODO
## [..] to-container	TODO
## [..] from-container	TODO
## [..] work-on		TODO
# - - -- --- ----- -------- Internals
## [ok] Work?
## [ok] Take
## [ok] Undecided
## [ok] ClearActive
## [ok] Place
## [ok] Queue
## [ok] Symbolize
## [ok] Results
# - - -- --- ----- -------- DSL for reducer decisions
## [ok] keep
## [ok] is-a
## [ok] is-a!
## [ok] rules
## [ok] rules!
## [ok] rules*
## [ok] rules*!

# # ## ### ##### ######## ############# #####################
## rstate constructor

test marpa-slif-literal-rstate-cons-1.0 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate new X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate new"}

test marpa-slif-literal-rstate-cons-1.1 {rstate, cons, wrong args, too many} -body {
    marpa::slif::literal rstate create R W X
} -returnCodes error -result {wrong # args: should be "marpa::slif::literal rstate create R"}

test marpa-slif-literal-rstate-cons-2.0 {rstate, cons, auto} -body {
    set r [marpa::slif::literal rstate new]
} -cleanup {
    $r destroy
    unset r
} -match glob -result ::oo::Obj*

test marpa-slif-literal-rstate-cons-2.1 {rstate, cons, explicitly named} -body {
    marpa::slif::literal rstate create R
} -cleanup {
    R destroy
} -result ::R

# # ## ### ##### ######## ############# #####################
## rstate Work?

test marpa-slif-literal-rstate-work?-1.0 {rstate, Work?, wrong args, too many} -setup {
    setup
} -body {
    R Work? X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Work?"}

test marpa-slif-literal-rstate-work?-2.0 {rstate, Work?, none} -setup {
    setup
} -body {
    R Work?
} -cleanup {
    R destroy
} -result 0

test marpa-slif-literal-rstate-work?-2.1 {rstate, Work?, some} -setup {
    setup {
	A {character 12}
	B {string 65 66 67}
    }
} -body {
    R Work?
} -cleanup {
    R destroy
} -result 2

# # ## ### ##### ######## ############# #####################
## rstate reduce

test marpa-slif-literal-rstate-reduce-1.0 {rstate, reduce, wrong args, not enough} -setup {
    setup
} -body {
    R reduce
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R reduce cmd ..."}

test marpa-slif-literal-rstate-reduce-1.1 {rstate, reduce, fail decision} -setup {
    proc nop {args} {}
    setup {
	A {byte 45}
    }
} -body {
    R reduce nop
} -cleanup {
    rename nop {}
    R destroy
} -returnCodes error -result {Failed to reduce: "nop reduce byte ::R 45"}

test marpa-slif-literal-rstate-reduce-2.0 {rstate, reduce, callback} -setup {
    # Do not use adjacent codepoints for our example. They cause the
    # class normalize to a range, which `foo` above will not deal
    # with.
    setup {
	A {charclass 45 48}
    }
    setup_foo
} -body {
    R reduce foo
} -cleanup {
    clear_foo
    catch {R destroy}
} -result {{@CHR:<-> {character 45} @CHR:<0> {character 48} A {composite @CHR:<-> @CHR:<0>}} {}}

# # ## ### ##### ######## ############# #####################
## rstate Take

test marpa-slif-literal-rstate-take-1.0 {rstate, Take, wrong args, too many} -setup {
    setup
} -body {
    R Take X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Take"}

test marpa-slif-literal-rstate-take-2.0 {rstate, Take, nothing} -setup {
    setup
} -body {
    R Take
} -cleanup {
    R destroy
} -returnCodes error -result {No work available}

test marpa-slif-literal-rstate-take-2.1 {rstate, Take, last (stack)} -setup {
    setup {
	B {string 65 66 67}
	A {character 78}
    }
} -body {
    R Take
    R Active
} -cleanup {
    R destroy
} -result {A {character 78}}

# # ## ### ##### ######## ############# #####################
## rstate Undecided

test marpa-slif-literal-rstate-undecided-1.0 {rstate, Undecided, wrong args, too many} -setup {
    setup
} -body {
    R Undecided X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Undecided"}

test marpa-slif-literal-rstate-undecided-2.0 {rstate, Undecided, initially not} -setup {
    setup
} -body {
    R Undecided
} -cleanup {
    R destroy
} -result 0

test marpa-slif-literal-rstate-undecided-2.1 {rstate, Undecided, yes after Take} -setup {
    setup {
	B {string 65 66 67}
	A {character 78}
    }
    R Take
} -body {
    R Undecided
} -cleanup {
    R destroy
} -result 1

testcases k {cmd} {
    keep
    {is-a  byte 5}
    {is-a! byte 5}
    {rules {}}
    {rules! {}}
    {rules*}
    {rules*!}
} {
    test marpa-slif-literal-rstate-undecided-2.2.$k "rstate, Undecided, no after $cmd" -setup {
	setup {
	    B {string 65 66 67}
	    A {character 78}
	}
	R Take
	RX {*}$cmd
    } -body {
	R Undecided
    } -cleanup {
	R destroy
    } -result 0
}

# # ## ### ##### ######## ############# #####################
## rstate ClearActive

test marpa-slif-literal-rstate-clearactive-1.0 {rstate, ClearActive, wrong args, too many} -setup {
    setup
} -body {
    R ClearActive X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R ClearActive"}

test marpa-slif-literal-rstate-clearactive-2.0 {rstate, ClearActive} -setup {
    setup {
	A {byte 4}
    }
} -body {
    list [R Take] [R Undecided] [R ClearActive] [R Undecided]
} -cleanup {
    R destroy
} -result {{} 1 {} 0}

# # ## ### ##### ######## ############# #####################
## rstate Place

test marpa-slif-literal-rstate-place-1.0 {rstate, Place, wrong args, not enough} -setup {
    setup
} -body {
    R Place
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.1 {rstate, Place, wrong args, not enough} -setup {
    setup
} -body {
    R Place Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.2 {rstate, Place, wrong args, not enough} -setup {
    setup
} -body {
    R Place Q SQ
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.3 {rstate, Place, wrong args, not enough} -setup {
    setup
} -body {
    R Place Q SQ S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-1.4 {rstate, Place, wrong args, too many} -setup {
    setup
} -body {
    R Place Q SQ S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Place queue symqueue litsymbol literal"}

test marpa-slif-literal-rstate-place-2.0.0 {rstate, Place (literal), results} -setup {
    setup
} -body {
    R Place done --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.0.1 {rstate, Place (literal), results, state} -setup {
    setup
} -body {
    R Place done --- S {character 45}
    R Results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-place-2.1.0 {rstate, Place (literal), work} -setup {
    setup
} -body {
    R Place work --- S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.1.1 {rstate, Place (literal), work, state} -setup {
    setup
} -body {
    R Place work --- S {character 45}
    R Take
    R Active
} -cleanup {
    R destroy
} -result {S {character 45}}

test marpa-slif-literal-rstate-place-2.2.0 {rstate, Place (composite), results} -setup {
    setup
} -body {
    R Place done done S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.2.1 {rstate, Place (composite), results, state} -setup {
    setup
} -body {
    R Place done done S {composite {{character 45}} {{character 46}}}
    list [R Work?] --- [R Results]
} -cleanup {
    R destroy
} -result {0 --- {{S {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}} {}}}

test marpa-slif-literal-rstate-place-2.3.0 {rstate, Place (composite), work} -setup {
    setup
} -body {
    R Place done work S {composite {{character 45}} {{character 46}}}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-place-2.3.1 {rstate, Place (composite), work, state} -setup {
    setup
} -body {
    R Place done work S {composite {{character 45}} {{character 46}}}
    list [R Work?] --- [R Results] --- [R Take; R Active] --- [R Take; R Active]
} -cleanup {
    R destroy
} -result {2 --- {{S {composite @CHR:<-> @CHR:<.>}} {}} --- {@CHR:<.> {character 46}} --- {@CHR:<-> {character 45}}}

# # ## ### ##### ######## ############# #####################
## rstate Queue

test marpa-slif-literal-rstate-queue-1.0 {rstate, Queue, wrong args, not enough} -setup {
    setup
} -body {
    R Queue
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.1 {rstate, Queue, wrong args, not enough} -setup {
    setup
} -body {
    R Queue Q
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.2 {rstate, Queue, wrong args, not enough} -setup {
    setup
} -body {
    R Queue Q S
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-1.3 {rstate, Queue, wrong args, too many} -setup {
    setup
} -body {
    R Queue Q S L X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Queue queue litsymbol literal"}

test marpa-slif-literal-rstate-queue-2.0.0 {rstate, Queue, results} -setup {
    setup
} -body {
    R Queue done S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.0.1 {rstate, Queue, results, state} -setup {
    setup
} -body {
    R Queue done S {character 45}
    R Results
} -cleanup {
    R destroy
} -result {{S {character 45}} {}}

test marpa-slif-literal-rstate-queue-2.1.0 {rstate, Queue, work} -setup {
    setup
} -body {
    R Queue work S {character 45}
} -cleanup {
    R destroy
} -result S

test marpa-slif-literal-rstate-queue-2.1.1 {rstate, Queue, work, state} -setup {
    setup
} -body {
    R Queue work S {character 45}
    R Take
    R Active
} -cleanup {
    R destroy
} -result {S {character 45}}

# # ## ### ##### ######## ############# #####################
## rstate Results

test marpa-slif-literal-rstate-results-1.0 {rstate, Results, wrong args, too many} -setup {
    setup
} -body {
    R Results X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R Results"}

test marpa-slif-literal-rstate-results-2.0 {rstate, Results} -setup {
    setup {
	A {character 12}
	B {string 65 66 67}
    }
    # Empty Results. Because this is all in the work-Queue.
} -body {
    R Results
} -cleanup {
    R destroy
} -result {{} {}}

test marpa-slif-literal-rstate-results-2.1 {rstate, Results} -setup {
    setup {
	A {character 12}
	B {string 65 66 67}
    }
    # Shift the initial work Queue over into Results, unchanged.
    R Queue done {*}[R Take ; R Active]
    R Queue done {*}[R Take ; R Active]
} -body {
    R Results
} -cleanup {
    R destroy
} -result {{A {character 12} B {string 65 66 67}} {}}

# # ## ### ##### ######## ############# #####################
## DSL for reducer decisions

# # ## ### ##### ######## ############# #####################
## rstate keep

test marpa-slif-literal-rstate-keep-1.0 {rstate, keep, wrong args, too many} -setup {
    setup
} -body {
    R keep X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R keep"}

test marpa-slif-literal-rstate-keep-2.0 {rstate, keep} -setup {
    setup {
	A {character 12}
    }
} -body {
    # Shift the initial work Queue over into results, unchanged.
    R Take
    RX keep
    # Show effect
    R Results
} -cleanup {
    R destroy
} -result {{A {character 12}} {}}

# # ## ### ##### ######## ############# #####################
## rstate is-a

test marpa-slif-literal-rstate-is-a-1.0 {rstate, is-a, wrong args, not enough} -setup {
    setup
} -body {
    R is-a
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R is-a newtype ..."}

test marpa-slif-literal-rstate-is-a-1.1 {rstate, is-a, illegal composite} -setup {
    setup
} -body {
    R is-a composite ...
} -cleanup {
    R destroy
} -returnCodes error -result {Bad type "composite" for simple change, use `rules` and variants}

test marpa-slif-literal-rstate-is-a-2.0 {rstate, is-a} -setup {
    setup {
	A {character 12}
    }
} -body {
    # Shift the initial work Queue back to work, change definition
    R Take
    RX is-a byte 12
    # And shit to results
    R Take
    RX keep
    # Show effect
    R Results
} -cleanup {
    R destroy
} -result {{A {byte 12}} {}}

# # ## ### ##### ######## ############# #####################
## rstate is-a!

test marpa-slif-literal-rstate-is-a!-1.0 {rstate, is-a!, wrong args, not enough} -setup {
    setup
} -body {
    R is-a!
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R is-a! newtype ..."}

test marpa-slif-literal-rstate-is-a!-1.1 {rstate, is-a!, illegal composite} -setup {
    setup
} -body {
    R is-a! composite ...
} -cleanup {
    R destroy
} -returnCodes error -result {Bad type "composite" for simple change, use `rules` and variants}

test marpa-slif-literal-rstate-is-a!-2.0 {rstate, is-a!} -setup {
    setup {
	A {character 12}
    }
} -body {
    # Shift the initial work Queue over into results, change definition
    R Take
    RX is-a! byte 12
    # Show effect
    R Results
} -cleanup {
    R destroy
} -result {{A {byte 12}} {}}

# # ## ### ##### ######## ############# #####################
## rstate rules

test marpa-slif-literal-rstate-rules-1.0 {rstate, rules, wrong args, not enough} -setup {
    setup
} -body {
    R rules
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R rules alternatives"}

test marpa-slif-literal-rstate-rules-1.1 {rstate, rules, wrong args, too many} -setup {
    setup
} -body {
    R rules A X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R rules alternatives"}

test marpa-slif-literal-rstate-rules-2.0 {rstate, rules, rewrite} -setup {
    setup {
	A {charclass 45 46}
    }
} -body {
    # Rewrite into results, pieces to work
    R Take
    RX rules {{{character 45}} {{character 46}}}
    # Shift pieces to result
    R Take ; RX keep
    R Take ; RX keep
    # Show
    R Results
} -cleanup {
    R destroy
} -result {{@CHR:<-> {character 45} @CHR:<.> {character 46} A {composite @CHR:<-> @CHR:<.>}} {}}

# # ## ### ##### ######## ############# #####################
## rstate rules!

test marpa-slif-literal-rstate-rules!-1.0 {rstate, rules!, wrong args, not enough} -setup {
    setup
} -body {
    R rules!
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R rules! alternatives"}

test marpa-slif-literal-rstate-rules!-1.1 {rstate, rules!, wrong args, too many} -setup {
    setup
} -body {
    R rules! A X
} -cleanup {
    R destroy
} -returnCodes error -result {wrong # args: should be "R rules! alternatives"}

test marpa-slif-literal-rstate-rules!-2.0 {rstate, rules!, rewrite} -setup {
    setup {
	A {charclass 45 46}
    }
} -body {
    # Rewrite into results, pieces to results
    R Take
    RX rules! {{{character 45}} {{character 46}}}
    # Show
    R Results
} -cleanup {
    R destroy
} -result {{A {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}} {}}

# # ## ### ##### ######## ############# #####################
## rstate rules*

test marpa-slif-literal-rstate-rules*-2.0 {rstate, rules*, rewrite} -setup {
    setup {
	A {charclass 45 46}
    }
} -body {
    # Rewrite into results, pieces to work
    R Take
    RX rules* {{character 45}} {{character 46}}
    # Shift pieces to result
    R Take ; RX keep
    R Take ; RX keep
    # Show
    R Results
} -cleanup {
    R destroy
} -result {{@CHR:<-> {character 45} @CHR:<.> {character 46} A {composite @CHR:<-> @CHR:<.>}} {}}

# # ## ### ##### ######## ############# #####################
## rstate rules*!

test marpa-slif-literal-rstate-rules*!-2.0 {rstate, rules*!, rewrite} -setup {
    setup {
	A {charclass 45 46}
    }
} -body {
    # Rewrite into results, pieces to results
    R Take
    RX rules*! {{character 45}} {{character 46}}
    # Show
    R Results
} -cleanup {
    R destroy
} -result {{A {composite @CHR:<-> @CHR:<.>} @CHR:<.> {character 46} @CHR:<-> {character 45}} {}}

# # ## ### ##### ######## ############# #####################
rename setup {}
rename RX {}
cleanupTests
return
