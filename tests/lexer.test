# -*- tcl -*- tcl.tk//DSL tcltest//EN//2.0 tcl.tk//DSL tcltest//EN//2.0
## (c) 2016-2017 Andreas Kupries
# # ## ### ##### ######## ############# #####################
## marpa::lexer

kt check Tcl     8.5
kt check tcltest 2

kt require support debug
kt require support debug::caller
kt require support oo::util
kt require support TclOO

kt local   testing marpa

# # ## ### ##### ######## ############# #####################
## Activate method sequence checking for all instances
## Instances can dynamically activate method sequence checks too

oo::define marpa::lexer mixin marpa::lexer::sequencer

# # ## ### ##### ######## ############# #####################

kt source support/common.tcl
kt source support/lexample.tcl
kt source support/fake-parse.tcl
kt source support/fake-store.tcl

# # ## ### ##### ######## ############# #####################
##  1 constructor/2 (semstore, parser)
# # -- --- ----- -------- -------------
##  2 gate:/1       (obj)
##  3 symbols/1     (names)
##  4 export/1      (names)
##  5 action/*      (...)
##  6 rules/1       (rules)
##  7 discard/1     (ignorelist)
# # -- --- ----- -------- -------------
##  8 acceptable/1  (syms)
# # -- --- ----- -------- -------------
##  9 enter/2       (syms semval)
##  A eof/0         ()
# # -- --- ----- -------- -------------
##  B redo/1        (n)

##    latm/1 -- see 2-6, same class -- TODO - p_lexer
##
## Sequence = 1([23456]*7(8(98?)*)?)?A
## See p_lexer.tcl, mark <<s>> (multiple)
##
#        |state
# -------+--------+
# method |made    |
# -------+--------+-------------------------
# gate:  | OK     | 2.1.0, 2.1.1, 2.2.2
# symbols| OK	  | 6.1.0, 6.1.1, 6.1.2
# export | OK	  | 3.1.0, 3.1.1, 3.1.2
# action | OK	  | 4.1.0, 4.1.1, 4.1.2
# rules  | OK	  | 7.1.0, 7.1.1, 7.1.2
# discard| OK	  | 8.[234].0, 8.[234].1 -- TODO: discard on empty grammar
# accept |  FAIL  | 1.3.1
# enter  |  FAIL  | 1.3.0
# eof    | OK	  | 11.1.0, 11.1.1, 11.1.2
# redo   |  FAIL  | 1.3.2
# -------+--------+
# method |config  |
# -------+--------+-------------------------
# gate:  |  FAIL  | 8.5.0
# symbols|  FAIL  | 8.5.1
# export |  FAIL  | 8.5.2
# action |  FAIL  | 8.5.3
# rules  |  FAIL  | 8.5.5
# discard|  FAIL  | 8.5.6
# accept | OK	  | 9.1.0, 9.1.1, 9.1.2
# enter  |  FAIL  | 8.5.7
# eof    | OK	  | 11.2.0, 11.2.1, 11.2.2
# redo   |  FAIL  | 8.5.8
# -------+--------+
# method |gated   |
# -------+--------+-------------------------
# gate:  |  FAIL  | 9.3.0
# symbols|  FAIL  | 9.3.1
# export |  FAIL  | 9.3.2
# action |  FAIL  | 9.3.3
# rules  |  FAIL  | 9.3.5
# discard|  FAIL  | 9.3.6
# accept |  FAIL  | 9.3.7
# enter  | OK	  | 10.1.0, 10.1.1, 10.1.2
# eof    | OK	  | 11.3.0, 11.3.1, 11.3.2
# redo   |  FAIL  | 9.3.8
# -------+--------+
# method |data    |
# -------+--------+-------------------------
# gate:  |  FAIL  | 10.3.0
# symbols|  FAIL  | 10.3.1
# export |  FAIL  | 10.3.2
# action |  FAIL  | 10.3.3
# rules  |  FAIL  | 10.3.5
# discard|  FAIL  | 10.3.6
# accept | OK	  | 9.2.0, 9.2.1, 9.2.2
# enter  | OK	  | 10.2.0, 10.2.1, 10.2.2
# eof    | OK	  | 11.4.0, 11.4.1, 11.4.2
# redo   |  FAIL  | 10.3.7
# -------+--------+
# method |done    |
# -------+--------+-------------------------
# gate:  |  FAIL  | 11.5.0
# symbols|  FAIL  | 11.5.1
# export |  FAIL  | 11.5.2
# action |  FAIL  | 11.5.3
# rules  |  FAIL  | 11.5.5
# discard|  FAIL  | 11.5.6
# accept | OK	  | 9.4.0, 9.4.1, 9.4.2
# enter  |  FAIL  | 11.5.7
# eof    |  FAIL  | 11.5.8
# redo   |  FAIL  | 11.5.9
# -------+--------+
# method |complete|
# -------+--------+-------------------------
# gate:  |  FAIL  | 9.5.0
# symbols|  FAIL  | 9.5.1
# export |  FAIL  | 9.5.2
# action |  FAIL  | 9.5.3
# rules  |  FAIL  | 9.5.5
# discard|  FAIL  | 9.5.6
# accept |  FAIL  | 9.5.7
# enter  |  FAIL  | 9.5.8
# eof    |  FAIL  | 9.5.9
# redo   |  FAIL  | 9.5.10
# -------+--------+

# # ## ### ##### ######## ############# #####################
## constructor - wrong args, initial state, calls

test marpa-lexer-1.0.0 {constructor, wrong args, not enough} -body {
    marpa::lexer new
} -returnCodes error -result {wrong # args: should be "marpa::lexer new semstore parser"}

test marpa-lexer-1.0.1 {constructor, wrong args, not enough} -body {
    marpa::lexer new STORE
} -returnCodes error -result {wrong # args: should be "marpa::lexer new semstore parser"}

test marpa-lexer-1.0.2 {constructor, wrong args, too many} -body {
    marpa::lexer new STORE PAR X
} -returnCodes error -result {wrong # args: should be "marpa::lexer new semstore parser"}

# No state to query ?! CHECK

test marpa-lexer-1.1 {constructor, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

test marpa-lexer-1.2 {constructor, externals} -body {
    marpa::lexer create LEXER [log STO] [log PAR]
    logged
} -cleanup {
    LEXER destroy
} -result {
  STO C {put {{} {} {}}}
  STO R {put {{} {} {}}} = {}
  PAR C {gate: ::LEXER}
  PAR R {gate: ::LEXER} = {}
}

test marpa-lexer-1.3.0 {constructor, post-forbidden: enter} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER enter 0 C V
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Setup missing}

test marpa-lexer-1.3.1 {constructor, post-forbidden: acceptable} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER acceptable {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Setup missing}

test marpa-lexer-1.3.2 {constructor, post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer cannot redo symbols}

# # ## ### ##### ######## ############# #####################
## gate: - wrong args, state, sequencing

test marpa-lexer-2.0.0 {gate:, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER gate:
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER gate: gate"}

test marpa-lexer-2.0.1 {gate:, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER gate: OBJ X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER gate: gate"}

test marpa-lexer-2.1.0 {gate:, result} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER gate: [log GATE]
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-2.1.1 {gate:, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    LEXER gate: [log GATE]
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-2.1.2 {gate:, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER gate: [log GATE]
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

# post-forbidden - see constructor (state: made)

# # ## ### ##### ######## ############# #####################
## export - wrong args, state, sequencing

test marpa-lexer-3.0.0 {export, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER export
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER export names"}

test marpa-lexer-3.0.1 {export, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER export OBJ X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER export names"}

test marpa-lexer-3.1.0 {export, result} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-3.1.1 {export, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    LEXER export {}
    logged
} -cleanup {
    LEXER destroy
} -result {
  PAR C {symbols {}}
  PAR R {symbols {}} = {}
}

test marpa-lexer-3.1.2 {export, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER export {}
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

# post-forbidden - see constructor (state: made)

# # ## ### ##### ######## ############# #####################
## action - wrong args, state, sequencing

test marpa-lexer-4.0.0 {action, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER action
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER action names"}

test marpa-lexer-4.0.1 {action, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER action NAMES X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER action names"}

test marpa-lexer-4.1.0 {action, result} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-4.1.1 {action, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    LEXER action {}
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-4.1.2 {action, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER action {}
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

# post-forbidden - see constructor (state: made)

# post-forbidden - see constructor (state: made)

# # ## ### ##### ######## ############# #####################
## symbols - wrong args, state, sequencing

test marpa-lexer-6.0.0 {symbols, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER symbols
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER symbols names"}

test marpa-lexer-6.0.1 {symbols, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER symbols OBJ X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER symbols names"}

test marpa-lexer-6.1.0 {symbols, result} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER symbols {a b}
} -cleanup {
    LEXER destroy
    logged
} -result {0 1}

test marpa-lexer-6.1.1 {symbols, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    LEXER symbols {a b}
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-6.1.2 {symbols, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER symbols {a b}
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

# post-forbidden - see constructor (state: made)

# # ## ### ##### ######## ############# #####################
## rules - wrong args, state, sequencing

test marpa-lexer-7.0.0 {rules, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER rules
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER rules rules"}

test marpa-lexer-7.0.1 {rules, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER rules OBJ X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER rules rules"}

test marpa-lexer-7.1.0 {rules, result} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-7.1.1 {rules, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    LEXER rules {}
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-7.1.2 {rules, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER rules {}
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result made

# TODO: rule commands (i.e. structure of the rules given to the method)

# post-forbidden - see constructor (state: made)

# # ## ### ##### ######## ############# #####################
## discard - wrong args, state, sequencing

test marpa-lexer-8.0.0 {discard, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER discard
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER discard discards"}

test marpa-lexer-8.0.1 {discard, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER discard DISCARDS X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER discard discards"}

# 8.1.x - TODO: Cannot discard exported symbol
# TODO: Cannot discard unknown symbol
# TODO: 'This grammar does not have any rules' -- Freeze error
# TODO: 'Start symbol not on LHS of any rule' -- Freeze error
# ----> export missing - No public symbols - No lexemes

test marpa-lexer-8.2.0 {discard, nothing is ok} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-8.2.1 {discard, something} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER W
    logclear
} -body {
    LEXER discard W
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-8.3.0 {discard, nothing, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER
    logclear
} -body {
    LEXER discard {}
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-8.3.1 {discard, something, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER W
    logclear
} -body {
    LEXER discard W
    logged
} -cleanup {
    LEXER destroy
} -result {}

test marpa-lexer-8.4.0 {discard, sequencing, nothing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER
} -body {
    LEXER discard {}
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result config

test marpa-lexer-8.4.1 {discard, sequencing, something} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER W
} -body {
    LEXER discard W
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result config

test marpa-lexer-8.5.0 {discard, post-forbidden: gate:} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER gate: X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.1 {discard, post-forbidden: symbols} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER symbols {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.2 {discard, post-forbidden: export} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.3 {discard, post-forbidden: action} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.5 {discard, post-forbidden: rules} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.6 {discard, post-forbidden: discard} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-8.5.7 {discard, post-forbidden: enter} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER enter 0 C V
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Gate missing}

test marpa-lexer-8.5.8 {discard, post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer cannot redo symbols}

# # ## ### ##### ######## ############# #####################
## acceptable - wrong args, state, sequencing

test marpa-lexer-9.0.0 {acceptable, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER acceptable
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER acceptable syms"}

test marpa-lexer-9.0.1 {acceptable, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GL LEXER
} -body {
    LEXER acceptable SYMS X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER acceptable syms"}

test marpa-lexer-9.1.0 {acceptable, initial} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    # @config
} -body {
    LEXER acceptable {0 1}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result {}

test marpa-lexer-9.1.1 {acceptable, initial, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
} -body {
    LEXER acceptable {0 1}
    LEXER @
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result gated

test marpa-lexer-9.1.2 {acceptable, initial, external} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    logclear
} -body {
    LEXER acceptable {0 1}
    logged
} -cleanup {
    LEXER destroy
    parsed ; stored
} -result {
  GATE C {acceptable {0 1}}
  GATE R {acceptable {0 1}} = {}
}

test marpa-lexer-9.2.0 {acceptable, end of lexeme} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    # @config
    LEXER acceptable {0 1} ;# parser A B
    # @gated
    LEXER enter 0 C 1
    # @data (no forward to parser, no acceptable coming back) - fake-parse-nil
} -body {
    # Explicitly do the 'acceptable' normally coming from the parser
    LEXER acceptable {0 1}
    # @gated - See below, 9.2.1
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result {}

test marpa-lexer-9.2.1 {acceptable, end of lexeme, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
    LEXER enter 0 C 1
} -body {
    LEXER acceptable {0 1}
    LEXER @
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result gated

test marpa-lexer-9.2.2 {acceptable, end of lexeme, external} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
    LEXER enter 0 C 1
    logclear
} -body {
    LEXER acceptable {0 1}
    logged
} -cleanup {
    LEXER destroy
    parsed ; stored
} -result {
  GATE C {acceptable {0 1}}
  GATE R {acceptable {0 1}} = {}
}

test marpa-lexer-9.3.0 {acceptable, post-forbidden: gate:} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER gate: X
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.1 {acceptable, post-forbidden: symbols} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER symbols {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.2 {acceptable, post-forbidden: export} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.3 {acceptable, post-forbidden: action} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.5 {acceptable, post-forbidden: rules} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.6 {acceptable, post-forbidden: discard} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.3.7 {acceptable, post-forbidden: acceptable} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER acceptable {0 1}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Data missing}

test marpa-lexer-9.3.8 {acceptable, post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer cannot redo symbols}

test marpa-lexer-9.4.0 {acceptable, post eof} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    # @done
} -body {
    LEXER acceptable {0 1}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result {}

test marpa-lexer-9.4.1 {acceptable, post eof, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
} -body {
    LEXER acceptable {0 1}
    LEXER @
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result complete

test marpa-lexer-9.4.2 {acceptable, post eof, external} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    logclear
} -body {
    LEXER acceptable {0 1}
    logged
} -cleanup {
    LEXER destroy
    parsed ; stored
} -result {
  GATE C {acceptable {0 1}}
  GATE R {acceptable {0 1}} = {}
}



test marpa-lexer-9.5.0 {acceptable, post-eof post-forbidden: gate:} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER gate: X
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.1 {acceptable, post-eof post-forbidden: symbols} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER symbols {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.2 {acceptable, post-eof post-forbidden: export} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.3 {acceptable, post-eof post-forbidden: action} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.5 {acceptable, post-eof post-forbidden: rules} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.6 {acceptable, post-eof post-forbidden: discard} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-9.5.7 {acceptable, post-eof post-forbidden: acceptable} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER acceptable {0 1}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {After end of input}

test marpa-lexer-9.5.8 {acceptable, post-eof post-forbidden: enter} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER enter 0 C 1
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {After end of input}

test marpa-lexer-9.5.9 {acceptable, post-eof post-forbidden: eof} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {After end of input}

test marpa-lexer-9.5.10 {acceptable, post-eof post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER eof
    LEXER acceptable {0 1}
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer cannot redo symbols}

# # ## ### ##### ######## ############# #####################
## enter - wrong args, state, sequencing

test marpa-lexer-10.0.0 {enter, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER enter
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER enter syms thechar thelocation"}

test marpa-lexer-10.0.1 {enter, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER enter CHARSYM
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER enter syms thechar thelocation"}

test marpa-lexer-10.0.2 {enter, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER enter CHARSYM CHAR
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER enter syms thechar thelocation"}

test marpa-lexer-10.0.3 {enter, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER enter CHARSYM CHAR VALUE X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER enter syms thechar thelocation"}

# TODO: unable to handle X - undefined character (class)

test marpa-lexer-10.1.0 {enter, start lexeme, result} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    # @config
    LEXER acceptable {0 1} ;# parser A B
    # @gated
} -body {
    LEXER enter 0 C 1
    # @data (no forward to parser, no acceptable coming back) - fake-parse-nil
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result {}

test marpa-lexer-10.1.1 {enter, start lexeme, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
} -body {
    LEXER enter 0 C 1
    LEXER @
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result data

test marpa-lexer-10.1.2 {enter, start lexeme, externals} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    logclear
} -body {
    LEXER enter 0 C 1
    logged
} -cleanup {
    LEXER destroy
    parsed ; stored
} -result {
  STO C {put C}
  STO R {put C} = 2
  PAR C {enter 0 2}
  PAR R {enter 0 2} = {}
  GATE C {redo 0}
  GATE R {redo 0} = {}
}

test marpa-lexer-10.2.0 {enter, intra lexeme, result} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    # @config
    LEXER acceptable {0 1} ;# parser A B
    # @gated
    LEXER enter 1 A 1
    # @data (no forward to parser, no acceptable coming back) - fake-parse-nil
} -body {
    LEXER enter 2 B 1
    # @data (no forward to parser, no acceptable coming back) - fake-parse-nil
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result {}

test marpa-lexer-10.2.1 {enter, intra lexeme, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER enter 2 B 1
    LEXER @
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -result data

test marpa-lexer-10.2.2 {enter, intra lexeme, externals} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
    logclear
} -body {
    LEXER enter 2 B 1
    logged
} -cleanup {
    LEXER destroy
    parsed ; stored
} -result {
  STO C {put AB}
  STO R {put AB} = 2
  PAR C {enter 1 2}
  PAR R {enter 1 2} = {}
  GATE C {redo 0}
  GATE R {redo 0} = {}
}

test marpa-lexer-10.3.0 {enter, intra lexeme, post-forbidden: gate:} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER gate: X
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.1 {enter, intra lexeme, post-forbidden: symbols} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER symbols {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.2 {enter, intra lexeme, post-forbidden: export} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.3 {enter, intra lexeme, post-forbidden: action} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.5 {enter, intra lexeme, post-forbidden: rules} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.6 {enter, intra lexeme, post-forbidden: discard} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-10.3.7 {enter, intra lexeme, post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 1 A 1
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged ; parsed ; stored
} -returnCodes error -result {Lexer cannot redo symbols}

# # ## ### ##### ######## ############# #####################
## eof - wrong args, state, sequencing

test marpa-lexer-11.0 {eof, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER eof X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER eof"}

test marpa-lexer-11.1.0 {eof, after construction} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-11.1.1 {eof, after construction, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER eof
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result done

test marpa-lexer-11.1.2 {eof, after construction, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    logclear
} -body {
    # eof is reported to parser, only.
    list [LEXER eof] [logged]
} -cleanup {
    LEXER destroy
} -result {{} {
  PAR C eof
  PAR R eof = {}
}}

test marpa-lexer-11.2.0 {eof, after config} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER; LEXER discard {}
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-11.2.1 {eof, after config, sequencing} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER; LEXER discard {}
} -body {
    LEXER eof
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result done

test marpa-lexer-11.2.2 {eof, after config, externals} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    GLBase LEXER; LEXER discard {}
    logclear
} -body {
    # eof is reported to parser, only.
    list [LEXER eof] [logged]
} -cleanup {
    LEXER destroy
} -result {{} {
  PAR C eof
  PAR R eof = {}
}}

test marpa-lexer-11.3.0 {eof, after accept, no enter, result} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-11.3.1 {eof, after accept, no enter, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
} -body {
    LEXER eof
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result done

test marpa-lexer-11.3.2 {eof, after accept, no enter, externals} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
    logclear
} -body {
    # No eof reported to parser, parse failure for incomplete (caught)
    catch { LEXER eof }
    logged
} -cleanup {
    LEXER destroy
} -result {
  PAR C eof
  PAR R eof = {}
}

test marpa-lexer-11.4.0 {eof, after enter} -setup {
    marpa::lexer create LEXER [log2 STO [set s [fake-store]]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1} ;# parser A B
    LEXER enter 0 C 1
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged
} -result {}

test marpa-lexer-11.4.1 {eof, after enter, sequencing} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
    LEXER enter 0 C 1
} -body {
    LEXER eof
    LEXER @
} -cleanup {
    LEXER destroy
    logged
} -result done

test marpa-lexer-11.4.2 {eof, after enter, externals} -setup {
    marpa::lexer create LEXER [log2 STO [fake-store]] [log2 PAR [fake-parse-nil]]
    LEXER gate: [log GATE] ; GL1 LEXER
    LEXER acceptable {0 1}
    LEXER enter 0 C 1
    logclear
} -body {
    # eof is reported to parser, only.
    list [LEXER eof] [logged]
} -cleanup {
    LEXER destroy
} -result {{} {
  PAR C eof
  PAR R eof = {}
}}



test marpa-lexer-11.5.0 {eof, post-forbidden: gate:} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER gate: X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.1 {eof, post-forbidden: symbols} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER symbols {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.2 {eof, post-forbidden: export} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER export {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.3 {eof, post-forbidden: action} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER action {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.5 {eof, post-forbidden: rules} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER rules {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.6 {eof, post-forbidden: discard} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER discard {}
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer is frozen}

test marpa-lexer-11.5.7 {eof, post-forbidden: enter} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER enter 0 C 1
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {After end of input}

test marpa-lexer-11.5.8 {eof, post-forbidden: eof} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER eof
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {After end of input}

test marpa-lexer-11.5.9 {eof, post-forbidden: redo} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
    LEXER eof
} -body {
    LEXER redo 0
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {Lexer cannot redo symbols}

# # ## ### ##### ######## ############# #####################
## redo - wrong args, state, sequencing

test marpa-lexer-12.0.0 {redo, wrong args, not enough} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER redo
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER redo n"}

test marpa-lexer-12.0.1 {redo, wrong args, too many} -setup {
    marpa::lexer create LEXER [log STO] [log PAR]
} -body {
    LEXER redo N X
} -cleanup {
    LEXER destroy
    logged
} -returnCodes error -result {wrong # args: should be "LEXER redo n"}

# Redo is forbidden everywhere, and handled already as part of the
# other methods.

# # ## ### ##### ######## ############# #####################
cleanupTests
