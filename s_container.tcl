# -*- tcl -*-
##
# (c) 2015-2017 Andreas Kupries http://wiki.tcl.tk/andreas%20kupries
#                          http://core.tcl.tk/akupries/
##
# This code is BSD-licensed.

# SLIF support. Container for the grammar information generated by the
# semantics from a SLIF definition

# # ## ### ##### ######## #############
## Requisites

package require Tcl 8.5
package require TclOO         ;# Implies Tcl 8.5 requirement.
package require debug
package require debug::caller
package require oo::util      ;# mymethod

debug define marpa/slif/container
#debug prefix marpa/slif/container {[debug caller] | }

# # ## ### ##### ######## #############
## 

oo::class create marpa::slif::container {
    marpa::E marpa/slif/container SLIF CONTAINER

    constructor {} {
	debug.marpa/slif/container {}

	# Attributes, global and lexeme semantics
	marpa::slif::attr/global create GA [self]
	marpa::slif::attr/lexsem create LS [self]

	# Grammars for the two levels.
	#marpa::slif::g1::grammar create G1 g1 [self]
	#marpa::slif::l0::grammar create L0 l0 [self]

	# TODO? semstore, used as a string pool
	debug.marpa/slif/container {/ok}
	return
    }

    # # -- --- ----- -------- -------------
    ## Toplevel API invoked by the semantics.
    ## Delegated to internl objects for actual handling.

    method g1 {args} {
	debug.marpa/slif/container {}
	return
    }
    # forward g1 G1

    method l0 {args} {
	debug.marpa/slif/container {}
	return
    }
    # forward l0 L0

    forward inaccessible     GA set inaccessible
    forward start!           GA set start
    forward lexeme-semantics LS set

    # # -- --- ----- -------- -------------
    ## Further public API - Introspection, (de)serialization, ...

    method serialize {} {
	debug.marpa/slif/container {}
	# Recursively generate a nested dict describing the container
	# contents
	dict set s global [GA serialize]
	dict set s lexeme [LS serialize]
	return $s
    }

    method deserialize {blob} {
	debug.marpa/slif/container {}
	return
    }

    method := {origin} {
	debug.marpa/slif/container {}
	my deserialize [$origin serialize]
	return
    }
    export :=

    method --> {destination} {
	debug.marpa/slif/container {}
	$destination deserialize [my serialize]
	return
    }
    export -->

    # # -- --- ----- -------- -------------
    ## Internal methods

    # # ## ### ##### ######## #############
}

# # ## ### ##### ######## #############
return
