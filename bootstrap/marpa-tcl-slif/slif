# # ## ### ##### ######## ############# #####################
## Copyright 2017 Andreas Kupries
#
# This file is part of MarpaTcl.  MarpaTcl is free software: you can
# redistribute it and/or modify it under the terms of the BSD 3-Clause
# License (Same license as Tcl itself is under).
#
# MarpaTcl is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# # ## ### ##### ######## ############# #####################
##
# This file contains a SLIF grammar derived from Jeffrey Kegler's
# original to account for Tcl's idiosyncrasies. And my own ;)
#
# - Removed blessings. They are a thoroughly Perl construct which
#   simply does not make sense for Tcl.
#
# - Encoded the adverb / context relationship into the syntax instead
#   of letting the semantics sort it out.
#
# - Redefined the string and character class syntax to match Tcl with
#   regard to the allowed escape sequences. The important point here
#   is that I encode the relevant constraints into the syntax instead
#   of letting the semantics break on bad input.
#
#   This is actually quite complex because a naive definition of the
#   escape sequences will introduce ambiguities into the grammar. As
#   the characters in a string or class are independent these will
#   multiply, for an exponential blowup with a power between 2 and 4,
#   depending on the mix of escapes.
#
#   As an example, look at the octal escape '\377'. With a naive
#   definition we get 3 possible readings, namely '\3'+'77',
#   '\37'+'7', and '\377'. In a similar manner the uncode escapes
#   ('\u...') will can have up to 4 readings.
#
#  To avoid the problem the grammar is more complex, with the rules
#  for the shorter escape sequences looking at their Follow() context
#  to decide whether to keep or abort them. The basic idea is to treat
#  the definition as a regexp, a finite automaton, which is translated
#  into a set of (indirect) right-recursive rules where the right-most
#  symbol of each rule encodes the state of the automaton for the
#  regexp. As a side note, here Marpa's use of Joop Leo's fix comes
#  into its own, preventing non-linear blowup in the earley items for
#  such rules.

# - Formatting (nice indentations and such)

# # ## ### ##### ######## ############# #####################
## Copyright statement of the original:
#
# Copyright 2015 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

# # ## ### ##### ######## ############# #####################
## Let us begin

:default ::=
  action => [start,length,values]

lexeme default =
  action => [start,length,value]
  latm   => 1

:start ::= statements

statements ::= statement+
statement ::=
    <start rule>
  | <empty rule>
  | <null statement>
  | <statement group>
  | <priority rule>
  | <quantified rule>
  | <discard rule>
  | <default rule>
  | <lexeme default statement>
  | <discard default statement>
  | <lexeme rule>
  | <completion event declaration>
  | <nulled event declaration>
  | <prediction event declaration>
  | <current lexer statement>
  | <inaccessible statement>

<null statement> ::= ';'
<statement group> ::= ('{') statements '}'
<start rule> ::= (':start' <op declare bnf>) symbol
<start rule> ::= ('start' 'symbol' 'is') symbol
<default rule> ::= ':default' <op declare bnf> <adverb list default>
<lexeme default statement> ::= ('lexeme' 'default' '=') <adverb list lexeme default>
<discard default statement> ::= ('discard' 'default' '=') <adverb list discard default>

<empty rule> ::= lhs <op declare bnf>   <adverb list bnf empty>
<empty rule> ::= lhs <op declare match> <adverb list match empty>

<quantified rule> ::= lhs <op declare bnf> <single symbol> quantifier <adverb list bnf quantified>
<quantified rule> ::= lhs <op declare match> <single symbol> quantifier <adverb list match quantified>

<discard rule> ::= (':discard' <op declare match>) symbol <adverb list discard>
<discard rule> ::= (':discard' <op declare match>) <character class> <adverb list discard>

# Expanded <single symbol> into its two possibilities, i.e. inlined
# its rules here, to make the differences visible to the semantics,
# i.e. actionable.

<lexeme rule>                  ::= (':lexeme' <op declare match>) symbol <adverb list lexeme>
<current lexer statement>      ::= ('current' 'lexer' 'is') <lexer name>

<completion event declaration> ::= ('event') <event initialization> ('=' 'completed') <symbol name>
<nulled event declaration>     ::= ('event') <event initialization> ('=' 'nulled') <symbol name>
<prediction event declaration> ::= ('event') <event initialization> ('=' 'predicted') <symbol name>

<inaccessible statement> ::= ('inaccessible' 'is') <inaccessible treatment> ('by' 'default')
<inaccessible treatment> ::= 'warn' | 'ok' | 'fatal'

<priority rule> ::= lhs (<op declare bnf>  ) <priorities bnf>
<priority rule> ::= lhs (<op declare match>) <priorities match>

<priorities bnf>   ::= <alternatives bnf>+
  separator => <op loosen>
  proper => 1

<priorities match> ::= <alternatives match>+
  separator => <op loosen>
  proper => 1

<alternatives bnf> ::= <alternative bnf>+
  separator => <op equal priority>
  proper => 1

<alternatives match> ::= <alternative match>+
  separator => <op equal priority>
  proper => 1

<alternative bnf>   ::= rhs <adverb list bnf alternative>
<alternative match> ::= rhs <adverb list match alternative>

<adverb list default>		::= <adverb list items default>
<adverb list discard>		::= <adverb list items discard>
<adverb list lexeme>		::= <adverb list items lexeme>
<adverb list discard default>	::= <adverb list items discard default>
<adverb list lexeme default>	::= <adverb list items lexeme default>
<adverb list bnf alternative>	::= <adverb list items bnf alternative>
<adverb list bnf empty>		::= <adverb list items bnf empty>
<adverb list bnf quantified>	::= <adverb list items bnf quantified>
<adverb list match alternative>	::= <adverb list items match alternative>
<adverb list match empty> 	::= <adverb list items match empty>
<adverb list match quantified>	::= <adverb list items match quantified>

<adverb list items default>		::= <adverb item default>*
<adverb list items discard>	    	::= <adverb item discard>*
<adverb list items lexeme>	    	::= <adverb item lexeme>*
<adverb list items discard default> 	::= <adverb item discard default>*
<adverb list items lexeme default>  	::= <adverb item lexeme default>*
<adverb list items bnf alternative> 	::= <adverb item bnf alternative>*
<adverb list items bnf empty>		::= <adverb item bnf empty>*
<adverb list items bnf quantified>	::= <adverb item bnf quantified>*
<adverb list items match alternative>	::= <adverb item match alternative>*
<adverb list items match empty>		::= <adverb item match empty>*
<adverb list items match quantified>	::= <adverb item match quantified>*

<adverb item default>		::= action            											| <null adverb>
<adverb item discard>	    	::= <event specification>										| <null adverb>
<adverb item lexeme>	    	::= <event specification> | <latm specification> | <priority specification> | <pause specification>	| <null adverb>
<adverb item discard default> 	::= <event specification>										| <null adverb>
<adverb item lexeme default>  	::= action            | <latm specification>								| <null adverb>
<adverb item bnf alternative> 	::= action            | <left association> | <right association> | <group association> | naming		| <null adverb>
<adverb item bnf empty>		::= action            | <left association> | <right association> | <group association> | naming		| <null adverb>
<adverb item bnf quantified>	::= action            | <separator specification> | <proper specification>				| <null adverb>
<adverb item match alternative>	::= naming												| <null adverb>
<adverb item match empty>	::= naming												| <null adverb>
<adverb item match quantified>	::= <separator specification> | <proper specification>							| <null adverb>

# NOTE: __unused__ <rank specification> <null ranking specification>

<null adverb>                ::= ','
action                       ::= ('action'       '=>') <action name>
<left association>           ::= ('assoc'        '=>' 'left')
<right association>          ::= ('assoc'        '=>' 'right')
<group association>          ::= ('assoc'        '=>' 'group')
<separator specification>    ::= ('separator'    '=>') <single symbol>
<proper specification>       ::= ('proper'       '=>') boolean
<rank specification>         ::= ('rank'         '=>') <signed integer>
<priority specification>     ::= ('priority'     '=>') <signed integer>
<pause specification>        ::= ('pause'        '=>') <before or after>
<null ranking specification> ::= ('null-ranking' '=>') <null ranking constant>
<null ranking specification> ::= ('null' 'rank'  '=>') <null ranking constant>
<event specification>        ::= ('event'        '=>') <event initialization>
<latm specification>         ::= ('forgiving'    '=>') boolean
<latm specification>         ::= ('latm'         '=>') boolean
<naming>                     ::= ('name'         '=>') <alternative name>

<null ranking constant>      ::= 'low' | 'high'

<event initialization> ::= <event name> <event initializer>
<event initializer> ::= ('=') <on or off>
<on or off> ::= 'on' | 'off'
<event initializer> ::= # empty

<alternative name> ::= <standard name> | <single quoted name>
<lexer name>       ::= <standard name> | <single quoted name>

<event name> ::=
   <standard name>
 | <single quoted name>
 | <reserved event name>

lhs ::= <symbol name>
rhs ::= <rhs primary>+

<rhs primary> ::= <single symbol>
<rhs primary> ::= <single quoted string>
<rhs primary> ::= <parenthesized rhs primary list>

<parenthesized rhs primary list> ::= ('(') <rhs primary list> (')')
<rhs primary list> ::= <rhs primary>+

<single symbol> ::=
    symbol
  | <character class>

symbol ::= <symbol name>

<symbol name> ::= <bare name> | <bracketed name>
<action name> ::= <Perl name> | <reserved action name> | <array descriptor>

# # ## ### ##### ######## ############# #####################
## Lexing, whitespace, including comments.

:discard ~ whitespace
whitespace ~ [[:space:]]+

# allow comments
:discard ~ <hash comment>

<hash comment> ~
   <terminated hash comment>
 | <unterminated final hash comment>

<terminated hash comment>         ~ '#' <hash comment body> <vertical space char>
<unterminated final hash comment> ~ '#' <hash comment body>

<hash comment body> ~ <hash comment char>*

<vertical space char> ~  [\n\v\f\r\u2028\u2029]
<hash comment char>   ~ [^\n\v\f\r\u2028\u2029]

# # ## ### ##### ######## ############# #####################

<op declare bnf> ~ '::='
<op declare match> ~ '~'
<op loosen> ~ '||'
<op equal priority> ~ '|'
quantifier ::= '*' | '+'
<before or after> ~ 'before' | 'after'

<signed integer> ~ <integer> | <sign> <integer>
<sign> ~ [+\55]
<integer> ~ [[:digit:]]+

boolean ~ [01]

<reserved event name>          ~ <double colon> <one or more word characters>
<reserved action name>         ~ <double colon> <one or more word characters>
<one or more word characters>  ~ [[:alnum:]_]+
<zero or more word characters> ~ [[:alnum:]_]*

# Perl identifiers allow an initial digit, which makes them slightly
# more liberal than Perl bare names but equivalent to Perl names with
# sigils.

<Perl identifier> ~ <one or more word characters>
<double colon> ~ '::'
<Perl name> ~ <Perl identifier>+
  separator => <double colon>
  proper    => 1

<bare name>      ~ <one or more word characters>
<standard name>  ~ [a-zA-Z] <zero or more word characters>
<bracketed name> ~ '<' <bracketed name string> '>'
<bracketed name string> ~ [[:alnum:]_[:space:]]+

<array descriptor> ~ <array descriptor left bracket>
                       <result item descriptor list>
		     <array descriptor right bracket>

<array descriptor left bracket> ~ '['
<array descriptor left bracket> ~ '[' whitespace

<array descriptor right bracket> ~ ']'
<array descriptor right bracket> ~ whitespace ']'

<result item descriptor list> ~ <result item descriptor>*
  separator => <result item descriptor separator>

<result item descriptor separator> ~ ','
<result item descriptor separator> ~ ',' whitespace

<result item descriptor> ~
    'start'
  | 'length'
  | 'g1start'
  | 'g1length'
  | 'name'
  | 'lhs'
  | 'symbol'
  | 'rule'
  | 'value'
  | 'values'

# # ## ### ##### ######## ############# #####################
## Strings of various kinds.

# For an explanation please look at the beginning of the file.
# The escapes handled here are (as a list of representative examples):
#
## \a   \r      \0      \uF
## \b   \t      \10     \uFF
## \f   \v      \100    \uFFF
## \n   \\      \xFF    \uFFFF
#
## In strings single-quotes (['], \134) may not appear directly.  In
## char-classes dash ('-', \55) and closing bracket (']', \135) may
## not appear directly. The line and paragraph separator characters
## (\u2028, \u2029) are forbidden as well.

<single quoted string> ~ <a single quoted string> <character class modifiers>
<single quoted name>   ~ <a single quoted string>

<a single quoted string> ~ <string open> <non empty string>

<non empty string>
        ~ <plain string char> <nullable string>
        | <escaped string char>

<escaped string char> ~ escape <escaped string char details>

<nullable string>
        ~ <string close>
        | <non empty string>

<escaped string char details>
        ~ control                     <nullable string>
        | 'x' hex hex                 <nullable string>
        | 'u' hex hex hex hex         <nullable string>
        | 'u' hex hex hex             <nullable string post short unicode escape>
        | 'u' hex hex                 <nullable string post short unicode escape>
        | 'u' hex                     <nullable string post short unicode escape>
        | <leading octal> octal octal <nullable string>
        | octal octal                 <nullable string post short octal escape>
        | octal                       <nullable string post short octal escape>

<nullable string post short unicode escape>
        ~ <escaped string char>
        | <plain string char without hex> <nullable string>
        | <string close>

<nullable string post short octal escape>
        ~ <escaped string char>
        | <plain string char without octal> <nullable string>
        | <string close>

<string open>   ~ [']
<string close>  ~ [']

octal           ~ [0-7]
<leading octal> ~ [0-3]
hex             ~ [[:xdigit:]]
control         ~ [abfnrtv\\]
escape          ~ '\\'

<plain string char>               ~ [^\a\b\f\n\r\t\v\\\u2028\u2029']
<plain string char without hex>   ~ [^[:xdigit:]\a\b\f\n\r\t\v\\\u2028\u2029']
<plain string char without octal> ~ [^0-7\a\b\f\n\r\t\v\\\u2028\u2029']

# # ## ### ##### ######## ############# #####################
## Character classes

# They allow the sames escapes as strings, so we have to take care of
# preventing ambiguity here as well. The same trick is used. However
# the individual elements have different Follow() contexts and a
# different end marker. This requires us to create all new symbols.

# The low-level octal and hexadecimal digits, the special characters,
# etc. can be re-used however, see the string section above for their
# definitions.

<character class> ~ <a character class> <character class modifiers>

<a character class> ~ <cc open> <cc element and more>

<cc element and more>
        ~ <plain cc element>
        | <escaped cc element>

<plain cc element>
	~ <plain cc char> <cc range completion>
	| <posix char class> <nullable cc>
	
<plain cc element without hex>
	~ <plain cc char without hex> <cc range completion>
	| <posix char class> <nullable cc>

<plain cc element without octal>
	~ <plain cc char without octal> <cc range completion>
	| <posix char class> <nullable cc>

<cc range completion>
        ~ '-' <plain cc char> <nullable cc>
        | '-' <escaped cc char>
        | <nullable cc>

<nullable cc>
        ~ <cc close>
        | <cc element and more>

<escaped cc element> ~ escape <escaped cc element details>

<escaped cc char> ~ escape <escaped cc char details>

<escaped cc element details>
        ~ control                     <cc range completion>
        | 'x' hex hex                 <cc range completion>
        | 'u' hex hex hex hex         <cc range completion>
        | 'u' hex hex hex             <cc range completion post short unicode escape>
        | 'u' hex hex                 <cc range completion post short unicode escape>
        | 'u' hex                     <cc range completion post short unicode escape>
        | <leading octal> octal octal <cc range completion>
        | octal octal                 <cc range completion post short octal escape>
        | octal                       <cc range completion post short octal escape>

<cc range completion post short unicode escape>
        ~ '-' <plain cc char> <nullable cc>
        | '-' <escaped cc char>
        | <escaped cc element>
        | <plain cc element without hex>
        | <cc close>

<cc range completion post short octal escape>
        ~ '-' <plain cc char> <nullable cc>
        | '-' <escaped cc char>
        | <escaped cc element>
        | <plain cc element without octal>
        | <cc close>

<escaped cc char details>
        ~ control                     <nullable cc>
        | 'x' hex hex                 <nullable cc>
        | 'u' hex hex hex hex         <nullable cc>
        | 'u' hex hex hex             <nullable cc post short unicode escape>
        | 'u' hex hex                 <nullable cc post short unicode escape>
        | 'u' hex                     <nullable cc post short unicode escape>
        | <leading octal> octal octal <nullable cc>
        | octal octal                 <nullable cc post short octal escape>
        | octal                       <nullable cc post short octal escape>

<nullable cc post short unicode escape>
        ~ <escaped cc char>
        | <plain cc char without hex> <nullable cc>
        | <cc close>

<nullable cc post short octal escape>
        ~ <escaped cc char>
        | <plain cc char without octal> <nullable cc>
        | <cc close>

<cc close> ~ ']'
<cc open>
        ~ '['
        | '[^'

<plain cc char>               ~ [^\a\b\f\n\r\t\v\\\u2028\u2029\135\55]
<plain cc char without hex>   ~ [^[:xdigit:]\a\b\f\n\r\t\v\\\u2028\u2029\135\55]
<plain cc char without octal> ~ [^0-7\a\b\f\n\r\t\v\\\u2028\u2029\135\55]

<posix char class>      ~ '[:' <posix char class name> ':]'
<posix char class name> ~ [[:alnum:]]+

<character class modifiers> ~ <character class modifier>*
<character class modifier> ~ ':ic'
<character class modifier> ~ ':i'
