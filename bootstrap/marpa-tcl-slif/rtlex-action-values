:default
::=
action
=>
[start,length,values]
lexeme
default
=
action
=>
[start,length,value]
latm
=>
1
:start
::=
statements
statements
::=
statement
+
statement
::=
<start rule>
|
<empty rule>
|
<null statement>
|
<statement group>
|
<priority rule>
|
<quantified rule>
|
<discard rule>
|
<default rule>
|
<lexeme default statement>
|
<discard default statement>
|
<lexeme rule>
|
<completion event declaration>
|
<nulled event declaration>
|
<prediction event declaration>
|
<current lexer statement>
|
<inaccessible statement>
<null statement>
::=
';'
<statement group>
::=
(
'{'
)
statements
'}'
<start rule>
::=
(
':start'
<op declare bnf>
)
symbol
<start rule>
::=
(
'start'
'symbol'
'is'
)
symbol
<default rule>
::=
':default'
<op declare bnf>
<adverb list default>
<lexeme default statement>
::=
(
'lexeme'
'default'
'='
)
<adverb list lexeme default>
<discard default statement>
::=
(
'discard'
'default'
'='
)
<adverb list discard default>
<empty rule>
::=
lhs
<op declare bnf>
<adverb list bnf empty>
<empty rule>
::=
lhs
<op declare match>
<adverb list match empty>
<quantified rule>
::=
lhs
<op declare bnf>
<single symbol>
quantifier
<adverb list bnf quantified>
<quantified rule>
::=
lhs
<op declare match>
<single symbol>
quantifier
<adverb list match quantified>
<discard rule>
::=
(
':discard'
<op declare match>
)
symbol
<adverb list discard>
<discard rule>
::=
(
':discard'
<op declare match>
)
<character class>
<adverb list discard>
<lexeme rule>
::=
(
':lexeme'
<op declare match>
)
symbol
<adverb list lexeme>
<current lexer statement>
::=
(
'current'
'lexer'
'is'
)
<lexer name>
<completion event declaration>
::=
(
'event'
)
<event initialization>
(
'='
'completed'
)
<symbol name>
<nulled event declaration>
::=
(
'event'
)
<event initialization>
(
'='
'nulled'
)
<symbol name>
<prediction event declaration>
::=
(
'event'
)
<event initialization>
(
'='
'predicted'
)
<symbol name>
<inaccessible statement>
::=
(
'inaccessible'
'is'
)
<inaccessible treatment>
(
'by'
'default'
)
<inaccessible treatment>
::=
'warn'
|
'ok'
|
'fatal'
<priority rule>
::=
lhs
(
<op declare bnf>
)
<priorities bnf>
<priority rule>
::=
lhs
(
<op declare match>
)
<priorities match>
<priorities bnf>
::=
<alternatives bnf>
+
separator
=>
<op loosen>
proper
=>
1
<priorities match>
::=
<alternatives match>
+
separator
=>
<op loosen>
proper
=>
1
<alternatives bnf>
::=
<alternative bnf>
+
separator
=>
<op equal priority>
proper
=>
1
<alternatives match>
::=
<alternative match>
+
separator
=>
<op equal priority>
proper
=>
1
<alternative bnf>
::=
rhs
<adverb list bnf alternative>
<alternative match>
::=
rhs
<adverb list match alternative>
<adverb list default>
::=
<adverb list items default>
<adverb list discard>
::=
<adverb list items discard>
<adverb list lexeme>
::=
<adverb list items lexeme>
<adverb list discard default>
::=
<adverb list items discard default>
<adverb list lexeme default>
::=
<adverb list items lexeme default>
<adverb list bnf alternative>
::=
<adverb list items bnf alternative>
<adverb list bnf empty>
::=
<adverb list items bnf empty>
<adverb list bnf quantified>
::=
<adverb list items bnf quantified>
<adverb list match alternative>
::=
<adverb list items match alternative>
<adverb list match empty>
::=
<adverb list items match empty>
<adverb list match quantified>
::=
<adverb list items match quantified>
<adverb list items default>
::=
<adverb item default>
*
<adverb list items discard>
::=
<adverb item discard>
*
<adverb list items lexeme>
::=
<adverb item lexeme>
*
<adverb list items discard default>
::=
<adverb item discard default>
*
<adverb list items lexeme default>
::=
<adverb item lexeme default>
*
<adverb list items bnf alternative>
::=
<adverb item bnf alternative>
*
<adverb list items bnf empty>
::=
<adverb item bnf empty>
*
<adverb list items bnf quantified>
::=
<adverb item bnf quantified>
*
<adverb list items match alternative>
::=
<adverb item match alternative>
*
<adverb list items match empty>
::=
<adverb item match empty>
*
<adverb list items match quantified>
::=
<adverb item match quantified>
*
<adverb item default>
::=
action
|
<null adverb>
<adverb item discard>
::=
<event specification>
|
<null adverb>
<adverb item lexeme>
::=
<event specification>
|
<latm specification>
|
<priority specification>
|
<pause specification>
|
<null adverb>
<adverb item discard default>
::=
<event specification>
|
<null adverb>
<adverb item lexeme default>
::=
action
|
<latm specification>
|
<null adverb>
<adverb item bnf alternative>
::=
action
|
<left association>
|
<right association>
|
<group association>
|
naming
|
<null adverb>
<adverb item bnf empty>
::=
action
|
<left association>
|
<right association>
|
<group association>
|
naming
|
<null adverb>
<adverb item bnf quantified>
::=
action
|
<separator specification>
|
<proper specification>
|
<null adverb>
<adverb item match alternative>
::=
naming
|
<null adverb>
<adverb item match empty>
::=
naming
|
<null adverb>
<adverb item match quantified>
::=
<separator specification>
|
<proper specification>
|
<null adverb>
<null adverb>
::=
','
action
::=
(
'action'
'=>'
)
<action name>
<left association>
::=
(
'assoc'
'=>'
'left'
)
<right association>
::=
(
'assoc'
'=>'
'right'
)
<group association>
::=
(
'assoc'
'=>'
'group'
)
<separator specification>
::=
(
'separator'
'=>'
)
<single symbol>
<proper specification>
::=
(
'proper'
'=>'
)
boolean
<rank specification>
::=
(
'rank'
'=>'
)
<signed integer>
<priority specification>
::=
(
'priority'
'=>'
)
<signed integer>
<pause specification>
::=
(
'pause'
'=>'
)
<before or after>
<null ranking specification>
::=
(
'null-ranking'
'=>'
)
<null ranking constant>
<null ranking specification>
::=
(
'null'
'rank'
'=>'
)
<null ranking constant>
<event specification>
::=
(
'event'
'=>'
)
<event initialization>
<latm specification>
::=
(
'forgiving'
'=>'
)
boolean
<latm specification>
::=
(
'latm'
'=>'
)
boolean
<naming>
::=
(
'name'
'=>'
)
<alternative name>
<null ranking constant>
::=
'low'
|
'high'
<event initialization>
::=
<event name>
<event initializer>
<event initializer>
::=
(
'='
)
<on or off>
<on or off>
::=
'on'
|
'off'
<event initializer>
::=
<alternative name>
::=
<standard name>
|
<single quoted name>
<lexer name>
::=
<standard name>
|
<single quoted name>
<event name>
::=
<standard name>
|
<single quoted name>
|
<reserved event name>
lhs
::=
<symbol name>
rhs
::=
<rhs primary>
+
<rhs primary>
::=
<single symbol>
<rhs primary>
::=
<single quoted string>
<rhs primary>
::=
<parenthesized rhs primary list>
<parenthesized rhs primary list>
::=
(
'('
)
<rhs primary list>
(
')'
)
<rhs primary list>
::=
<rhs primary>
+
<single symbol>
::=
symbol
|
<character class>
symbol
::=
<symbol name>
<symbol name>
::=
<bare name>
|
<bracketed name>
<action name>
::=
<Perl name>
|
<reserved action name>
|
<array descriptor>
:discard
~
whitespace
whitespace
~
[[:space:]]
+
:discard
~
<hash comment>
<hash comment>
~
<terminated hash comment>
|
<unterminated final hash comment>
<terminated hash comment>
~
'#'
<hash comment body>
<vertical space char>
<unterminated final hash comment>
~
'#'
<hash comment body>
<hash comment body>
~
<hash comment char>
*
<vertical space char>
~
[\n\v\f\r\u2028\u2029]
<hash comment char>
~
[^\n\v\f\r\u2028\u2029]
<op declare bnf>
~
'::='
<op declare match>
~
'~'
<op loosen>
~
'||'
<op equal priority>
~
'|'
quantifier
::=
'*'
|
'+'
<before or after>
~
'before'
|
'after'
<signed integer>
~
<integer>
|
<sign>
<integer>
<sign>
~
[+\55]
<integer>
~
[[:digit:]]
+
boolean
~
[01]
<reserved event name>
~
<double colon>
<one or more word characters>
<reserved action name>
~
<double colon>
<one or more word characters>
<one or more word characters>
~
[[:alnum:]_]
+
<zero or more word characters>
~
[[:alnum:]_]
*
<Perl identifier>
~
<one or more word characters>
<double colon>
~
'::'
<Perl name>
~
<Perl identifier>
+
separator
=>
<double colon>
proper
=>
1
<bare name>
~
<one or more word characters>
<standard name>
~
[a-zA-Z]
<zero or more word characters>
<bracketed name>
~
'<'
<bracketed name string>
'>'
<bracketed name string>
~
[[:alnum:]_[:space:]]
+
<array descriptor>
~
<array descriptor left bracket>
<result item descriptor list>
<array descriptor right bracket>
<array descriptor left bracket>
~
'['
<array descriptor left bracket>
~
'['
whitespace
<array descriptor right bracket>
~
']'
<array descriptor right bracket>
~
whitespace
']'
<result item descriptor list>
~
<result item descriptor>
*
separator
=>
<result item descriptor separator>
<result item descriptor separator>
~
','
<result item descriptor separator>
~
','
whitespace
<result item descriptor>
~
'start'
|
'length'
|
'g1start'
|
'g1length'
|
'name'
|
'lhs'
|
'symbol'
|
'rule'
|
'value'
|
'values'
<single quoted string>
~
<a single quoted string>
<character class modifiers>
<single quoted name>
~
<a single quoted string>
<a single quoted string>
~
<string open>
<non empty string>
<non empty string>
~
<plain string char>
<nullable string>
|
<escaped string char>
<escaped string char>
~
escape
<escaped string char details>
<nullable string>
~
<string close>
|
<non empty string>
<escaped string char details>
~
control
<nullable string>
|
'x'
hex
hex
<nullable string>
|
'u'
hex
hex
hex
hex
<nullable string>
|
'u'
hex
hex
hex
<nullable string post short unicode escape>
|
'u'
hex
hex
<nullable string post short unicode escape>
|
'u'
hex
<nullable string post short unicode escape>
|
<leading octal>
octal
octal
<nullable string>
|
octal
octal
<nullable string post short octal escape>
|
octal
<nullable string post short octal escape>
<nullable string post short unicode escape>
~
<escaped string char>
|
<plain string char without hex>
<nullable string>
|
<string close>
<nullable string post short octal escape>
~
<escaped string char>
|
<plain string char without octal>
<nullable string>
|
<string close>
<string open>
~
[']
<string close>
~
[']
octal
~
[0-7]
<leading octal>
~
[0-3]
hex
~
[[:xdigit:]]
control
~
[abfnrtv\\]
escape
~
'\\'
<plain string char>
~
[^\a\b\f\n\r\t\v\\\u2028\u2029']
<plain string char without hex>
~
[^[:xdigit:]\a\b\f\n\r\t\v\\\u2028\u2029']
<plain string char without octal>
~
[^0-7\a\b\f\n\r\t\v\\\u2028\u2029']
<character class>
~
<a character class>
<character class modifiers>
<a character class>
~
<cc open>
<cc element and more>
<cc element and more>
~
<plain cc element>
|
<escaped cc element>
<plain cc element>
~
<plain cc char>
<cc range completion>
|
<posix char class>
<nullable cc>
<plain cc element without hex>
~
<plain cc char without hex>
<cc range completion>
|
<posix char class>
<nullable cc>
<plain cc element without octal>
~
<plain cc char without octal>
<cc range completion>
|
<posix char class>
<nullable cc>
<cc range completion>
~
'-'
<plain cc char>
<nullable cc>
|
'-'
<escaped cc char>
|
<nullable cc>
<nullable cc>
~
<cc close>
|
<cc element and more>
<escaped cc element>
~
escape
<escaped cc element details>
<escaped cc char>
~
escape
<escaped cc char details>
<escaped cc element details>
~
control
<cc range completion>
|
'x'
hex
hex
<cc range completion>
|
'u'
hex
hex
hex
hex
<cc range completion>
|
'u'
hex
hex
hex
<cc range completion post short unicode escape>
|
'u'
hex
hex
<cc range completion post short unicode escape>
|
'u'
hex
<cc range completion post short unicode escape>
|
<leading octal>
octal
octal
<cc range completion>
|
octal
octal
<cc range completion post short octal escape>
|
octal
<cc range completion post short octal escape>
<cc range completion post short unicode escape>
~
'-'
<plain cc char>
<nullable cc>
|
'-'
<escaped cc char>
|
<escaped cc element>
|
<plain cc element without hex>
|
<cc close>
<cc range completion post short octal escape>
~
'-'
<plain cc char>
<nullable cc>
|
'-'
<escaped cc char>
|
<escaped cc element>
|
<plain cc element without octal>
|
<cc close>
<escaped cc char details>
~
control
<nullable cc>
|
'x'
hex
hex
<nullable cc>
|
'u'
hex
hex
hex
hex
<nullable cc>
|
'u'
hex
hex
hex
<nullable cc post short unicode escape>
|
'u'
hex
hex
<nullable cc post short unicode escape>
|
'u'
hex
<nullable cc post short unicode escape>
|
<leading octal>
octal
octal
<nullable cc>
|
octal
octal
<nullable cc post short octal escape>
|
octal
<nullable cc post short octal escape>
<nullable cc post short unicode escape>
~
<escaped cc char>
|
<plain cc char without hex>
<nullable cc>
|
<cc close>
<nullable cc post short octal escape>
~
<escaped cc char>
|
<plain cc char without octal>
<nullable cc>
|
<cc close>
<cc close>
~
']'
<cc open>
~
'['
|
'[^'
<plain cc char>
~
[^\a\b\f\n\r\t\v\\\u2028\u2029\135\55]
<plain cc char without hex>
~
[^[:xdigit:]\a\b\f\n\r\t\v\\\u2028\u2029\135\55]
<plain cc char without octal>
~
[^0-7\a\b\f\n\r\t\v\\\u2028\u2029\135\55]
<posix char class>
~
'[:'
<posix char class name>
':]'
<posix char class name>
~
[[:alnum:]]
+
<character class modifiers>
~
<character class modifier>
*
<character class modifier>
~
':ic'
<character class modifier>
~
':i'
