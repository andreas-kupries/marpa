# -*- tcl -*-
##
# (c) 2015-present Andreas Kupries http://wiki.tcl.tk/andreas%20kupries
#                                  http://core.tcl.tk/akupries/
##
# This code is BSD-licensed.

# SLIF support. Container for the grammar information generated by the
# semantics from a SLIF definition

# # ## ### ##### ######## #############
## Requisites

package require Tcl 8.5
package require TclOO         ;# Implies Tcl 8.5 requirement.
package require debug
package require debug::caller
package require oo::util      ;# mymethod

debug define marpa/slif/container
#debug prefix marpa/slif/container {[debug caller] | }

# # ## ### ##### ######## #############
##

oo::class create marpa::slif::container {
    superclass marpa::slif::container::serdes

    marpa::E marpa/slif/container SLIF CONTAINER

    constructor {} {
	debug.marpa/slif/container {}
	# Note, all subordinate objects get a reference back to the
	# container they are a part of.

	# Attributes, global and lexeme semantics
	marpa::slif::container::attribute::global create GA [self]
	marpa::slif::container::attribute::lexsem create LS [self]

	# Grammars for the two levels.
	marpa::slif::container::grammar::g1 create G1 [self]
	marpa::slif::container::grammar::l0 create L0 [self]

	# TODO? semstore, used as a string pool
	debug.marpa/slif/container {/ok}

	set myevent {}
	return
    }

    # # -- --- ----- -------- -------------
    ## Toplevel API invoked by the semantics.
    ## Delegated to internal objects for actual handling.

    forward g1               G1
    forward l0               L0
    forward inaccessible     GA set inaccessible
    forward start!           GA set start
    forward lexeme-semantics LS set

    forward lexeme-semantics? LS get
    forward start?            GA get start
    forward inaccessible?     GA get inaccessible

    # Ignore comments from the semantics
    method comment {args} {}

    # # -- --- ----- -------- -------------
    ## Further public API - Introspection, (de)serialization, ...

    method serialize {} {
	debug.marpa/slif/container {}
	# Recursively generate a nested dict describing the container
	# contents. Empty parts are not placed into the result.

	set serial {}
	foreach {label part} {
	    global GA
	    lexeme LS
	    g1     G1
	    l0     L0
	} {
	    set child [$part serialize]
	    if {![llength $child]} continue
	    dict set serial $label $child
	}

	# Non-object global: declared events
	if {[dict size $myevent]} {
	    dict set serial event $myevent
	}

	return $serial
    }

    method deserialize {blob} {
	debug.marpa/slif/container {}
	# Recursively push parts of the incoming blob to the child
	# handling it. Missing parts are ignored, except that the
	# associated child is cleared.

	# Note: GA is handled after G1, because its validation of
	# start! checks that the specified symbol exists in that
	# grammar.
	foreach {label part} {
	    lexeme LS
	    g1     G1
	    l0     L0
	    global GA
	} {
	    $part clear
	    if {![dict exists $blob $label]} continue
	    $part deserialize [dict get $blob $label]
	}

	# Non-object global: declared events
	if {[dict exists $blob event]} {
	    set myevent [dict get $blob event]
	}

	return
    }

    method validate {} {
	debug.marpa/slif/container {}
	LS validate
	G1 validate
	L0 validate
	GA validate
	return
    }

    method events {} {
	debug.marpa/slif/container {}
	if {![dict size $myevent]} {
	    return {}
	}
	return [lrange $myevent 0 end]
	# See the note in alter.tcl for explanation of the lrange.
    }

    # # -- --- ----- -------- -------------
    ## Semi-public API - Event database

    variable myevent ;# dict (name -> bool)

    method event {name state} {
	debug.marpa/slif/container {}
	dict set myevent $name $state
	return
    }

    # # -- --- ----- -------- -------------
    ## Internal methods

    # # ## ### ##### ######## #############
}

# # ## ### ##### ######## #############
return
